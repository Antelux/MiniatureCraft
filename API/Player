local Assets = require "Assets"
local Screen = require "API/Buffer"
local Level = require "API/Level"
local playerData, name_cache, ty = {}, {}, type
local remove = table.remove
local smt = setmetatable

local function isString(s) return ty(s) == "string"  end
local function isNumber(n) return ty(n) == "number"  end
local function isBool(b)   return ty(b) == "boolean" end
local function isTable(t)  return ty(t) == "table"   end

local function updateInventory(player)
    local inv = player.inventory
    for i = 1, #inv do
        local slot = inv[i]
        if slot and ((slot[2] <= 0) or (slot[3] and slot[3] <= 0)) then remove(inv, i) end
    end
    player.heldItem = (inv[player.heldItem] and player.heldItem) or (#inv ~= 0 and #inv) or false
end

local PlayerFunctions = {
    isAlive        = function(player) return player.health > 0        end,
    isTakingDamage = function(player) return player.invincibility > 0 end,
    direction      = function(player, dir) player.dir = not player.lock and dir or player.dir end,

    defense = function(player)
        local armor, def = player.armor, 0
        for i = 1, #armor do def = def + (Assets[armor[i]].protection or 0) end; return def
    end,

    giveItem = function(player, id, amount, damage)
        if not Assets[id] then return end; local inv = player.inventory
        for i = 1, #inv do
            if inv[i][1] == id then
                local newAmount = inv[i][2] + amount
                if newAmount <= (Assets[id].maxStack or 99) then
                    inv[i][2] = newAmount; updateInventory(player); return
                end
            end
        end
        inv[#inv + 1] = {id, amount, Assets[id].durability}; updateInventory(player)
    end,

    -- Make this function better. Won't remove everything properly if item is distributed among multiple stacks.
    removeItem = function(player, id, amount)
        local inv = player.inventory
        for i = 1, #inv do
            if inv[i][1] == id then
                inv[i][2] = inv[i][2] - amount; break
            end
        end
        updateInventory(player)
    end,

    itemDurability = function(player, slot, amount) 
        local inv = player.inventory
        if inv[slot] and inv[slot][3] then 
            if isNumber(amount) then inv[slot][3] = inv[slot][3] + amount else return inv[slot][3] end
            updateInventory(player)
        end
    end,

    checkInventory = function(player, id)
        local totalAmount, slots = 0, {}
        local inv = player.inventory
        for i = 1, #inv do
            if inv[i][1] == id then
                totalAmount = totalAmount + inv[i][2]; slots[#slots + 1] = {i, inv[i][2]}
            end
        end
        return slots, totalAmount
    end,

    getFacingCoords = function(player)
        local dir = player.direction
        return player.x + (dir == 2 and 1) or (dir == 4 and -1) or 0, player.y + (dir == 1 and -1) or (dir == 3 and 1) or 0
    end,

    useHeldItem = function(player)

    end
}
PlayerFunctions.__index = PlayerFunctions

local function newPlayerInternal(playerName, overrideTable, overwrite)
    if playerData[playerName] and not overwrite then return end
    playerData[playerName] = smt({name = playerName, x = 0, y = 0, color = colors.red, dir = math.random(4), heldItem = false, lock = false, dim = 0, mode = 0, energy = 20, health = 20, invincibility = 0, canRegenEnergy = true, speed = 20, inventory = {}, armor = {}}, PlayerFunctions)
    if isTable(overrideTable) then for k, v in pairs(overrideTable) do playerData[playerName][k] = v end end; name_cache[#name_cache + 1] = playerName; return playerData[playerName]
end

return {
    new = function(playerName, overrideTable)
        return newPlayerInternal(playerName, overrideTable)
    end,

    players = function(newPlayers) 
        if isTable(newPlayers) then 
            playerData = {}; name_cache = {}
            for name, data in pairs(newPlayers) do
                newPlayerInternal(name, data)
            end
        else return playerData end
    end,

    player = function(playerName, newData) 
        if isTable(newData) then newPlayerInternal(playerName, newData, true) else return playerData[playerName] end
    end,

    names  = function() return name_cache end, 
    update = function()
        for i = 1, #name_cache do
            local player = playerData[name_cache[i]]
            local newEnergy = player.canRegenEnergy and player.energy + 2 or player.energy
            player.invincibility = (player.invincibility > 0 and player.invincibility - 1) or 0
            player.energy, player.health = newEnergy <= 20 and newEnergy or 20, player.health <= 20 and player.health or 20 
        end
    end
}