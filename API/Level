local Assets = require "Assets"
local Noise = require "API/Noise"
local Time, Spawn, WorldName = math.random(8, 12), {}
local Seed = math.random(os.time() * 1000000)
local Chunks, chunks_cache = {[-3] = {}, [-2] = {}, [-1] = {}, [0] = {}, [1] = {}}, {}
local Asset_Cache = {}; for k, v in pairs(Assets) do if type(v) == "number" then Asset_Cache[v.name] = k end end
local random, randomseed, floor = math.random, math.randomseed, math.floor
local Noise_FBM = Noise.FBM
local remove = table.remove
local ty = type

local function isString(s) return ty(s) == "string"  end
local function isNumber(n) return ty(n) == "number"  end
local function isBool(b)   return ty(b) == "boolean" end
local function isTable(t)  return ty(t) == "table"   end
local function isNil(n)    return ty(n) == "nil"     end

local function unloadChunkInternal(dim, x, y, rem)
    if not Chunks[dim][y] or not Chunks[dim][y][x] then return end
    local currentChunk = Chunks[dim][y][x]
    if currentChunk.save then

    end
    if rem then remove(chunks_cache, currentChunk.cache_id) end
    Chunks[dim][y][x] = nil
end

local function updateChunkInternal(dim, x, y)
    local cx, cy = floor((x - 1) * 0.0625), floor((y - 1) * 0.0625)
    if not Chunks[dim][cy] or not Chunks[dim][cy][cx] then return end
    local currentChunk = Chunks[dim][cy][cx]
    local xc, yc = x - (cx * 16), y - (cy * 16)
    local center = currentChunk[yc][xc]

    for y = 1, 16 do
        for x = 1, 16 do
            local tileTick = Assets[center[1]].tick or function(c) return c end
            local blockTick = Assets[center[5]] and Assets[center[5]].tick or function(c) return c end
            Chunks[dim][cy][cx] = tileTick(currentChunk, dim, xc, yc)
            Chunks[dim][cy][cx] = blockTick(currentChunk, dim, xc, yc)
        end
    end
end

return {
    loadChunk = function(dim, x, y)
        if Chunks[dim][y] and Chunks[dim][y][x] then return end
        local cx, cy = x * 16, y * 16
        local cache_id = #chunks_cache + 1
        local newChunk = {save = false, cache = cache_id}
        
        -- Have a table of all lights and their radius in the world
        -- Ex: {{x, y, r}, {x, y, r}, ...}
        -- Draw accordingly in main loop

        if dim == 0 then
            for y = 1, 16 do
                newChunk[y] = {}
                for x = 1, 16 do
                    local elevation = Noise_FBM(8, cx + x, cy + y, 0.5, .007)
                    randomseed(elevation * 100000000 + (x*y))--; random(); random(); random()

                        if elevation <= .33 then newChunk[y][x] = {51, random(2), random(0, 5) * 0.1} -- Water
                    elseif elevation <= .36 then newChunk[y][x] = {56} -- Sand
                    elseif elevation <= .6  then newChunk[y][x] = {50, _, _, _, random(20) == 1 and random(26, 28) or nil} -- Grass / Flowers
                    elseif elevation <= .7  then newChunk[y][x] = {69} -- Snow
                    else newChunk[y][x] = {55, _, _, _, random(20) <= 18 and 1 or 8} end -- Stone/Coal Ore with dirt
                end
            end
        end

        chunks_cache[cache_id] = {dim, x, y}
        Chunks[dim][y] = Chunks[dim][y] or {}; Chunks[dim][y][x] = newChunk
    end,

    unloadChunk = function(dim, x, y)
        if not isNumber(x) or not isNumber(y) then
            for i = 1, #chunks_cache do
                local current_cache = chunks_cache[i]
                if current_cache[1] == dim then
                    unloadChunkInternal(current_cache[1], current_cache[2], current_cache[3])
                end
            end
        end
        unloadChunkInternal(dim, x, y, true)
    end,

    updateChunk = function(dim, x, y)
        if not isNumber(x) or not isNumber(y) then
            
        end
        updateChunkInternal(dim, x, y)
    end,

    chunkIsLoaded = function(dim, x, y)
        return Chunks[dim][y] and Chunks[dim][y][x]
    end,

    -- You need to load the chunk you're accessing before using the functions getTexture, setData, and getData.
    getTexture = function(dim, x, y)
        local cx, cy = floor((x - 1) * 0.0625), floor((y - 1) * 0.0625)
        if not Chunks[dim][cy] or not Chunks[dim][cy][cx] then return 32768, 1, " " end
        local spot = Chunks[dim][cy][cx][y - (cy * 16)][x - (cx * 16)]; if not spot then return 32768, 1, " " end

        local function getTileTexture()
            local tile = Assets[spot[1]]
            local tileTexture = tile.texture
            if not spot[3] then return tileTexture[1], tileTexture[2], tileTexture[3] else
                spot[3] = spot[3] + 0.05; if spot[3] > tile.animationSpeed then spot[2], spot[3] = spot[2] + 1, 0 end
                if spot[2] > #tileTexture / 3 then spot[2] = 1 end; local aoff = (spot[2] - 1) * 3
                return tileTexture[1 + aoff], tileTexture[2 + aoff], tileTexture[3 + aoff]
            end
        end

        local block = Assets[spot[5]]
        if block then 
            local blockTexture, blockTimer = block.texture, spot[7]
            if not blockTimer then return blockTexture[1] or getTileTexture(), blockTexture[2], blockTexture[3] else
                spot[7] = spot[7] + 0.05; if spot[7] > block.animationSpeed then spot[6], spot[7] = spot[6] + 1, 0 end
                if spot[6] > #blockTexture / 3 then spot[6] = 1 end; local aoff = (spot[6] - 1) * 3
                return blockTexture[1 + aoff] or getTileTexture(), blockTexture[2 + aoff], blockTexture[3 + aoff]
            end
        end 

        return getTileTexture()
    end,

    --    1            2                3              4        5            6                7                 8           9
    -- {tileID, tileAnimation, tileAnimationTimer, tileData, blockID, blockAnimation, blockAnimationTimer, blockHealth, blockData}
    data = function(dim, x, y, tileID, tileData, blockID, blockData)
        local cx, cy = floor((x - 1) * 0.0625), floor((y - 1) * 0.0625)
        if not Chunks[dim][cy] or not Chunks[dim][cy][cx] then return end
        local spot = Chunks[dim][cy][cx][y - (cy * 16)][x - (cx * 16)]

        if (not tileID and not tileData and isNil(blockID) and not blockData) or not spot then return spot end
        if isNumber(tileID) then 
            local tile = Assets[tileID]; if not tile then return end; local speed = tile.animationSpeed 
            spot[1] = tileID or spot[1]; spot[2] = 1; spot[3] = speed and random(0, speed*10) * 0.1; spot[4] = tileData or spot[4]
        end
        if isNumber(blockID) then 
            local block = Assets[blockID]; if not block  then return end; local speed = block.animationSpeed
            spot[5] = blockID or spot[5]; spot[6] = 1; spot[7] = speed and random(0, speed*10) * 0.1; spot[8] = Assets[blockID].health; spot[9] = blockData or spot[9]
        elseif isBool(blockID) and blockID == false then
            spot[5] = nil; spot[6] = nil; spot[7] = nil; spot[8] = nil; spot[9] = nil
        end; spot.save = true
    end,

    checkForCollision = function(dim, x, y, banned)
        local cx, cy = floor((x - 1) * 0.0625), floor((y - 1) * 0.0625)
        if not Chunks[dim][cy] or not Chunks[dim][cy][cx] then return end
        local spot = Chunks[dim][cy][cx][y - (cy * 16)][x - (cx * 16)]
        local block = Assets[spot[5]]; if not spot or (block and block.type == "block") then return true end
        local tile = spot[1]; if banned then for i = 1, #banned do if banned[i] == tile then return true end end end
    end,

    convertID = function(id)
        return (isString(id) and Asset_Cache[id]) or isNumber(id) and Assets[id] and Assets[id].name 
    end,

    loadStructure = function(file, name)
        if not fs.exists(file) then return end

    end,

    time = function(newTime) if isNumber(newTime) then Time = newTime else return Time end end,
    spawn = function(x, y) if isNumber(x) and isNumber(y) then Spawn[1], Spawn[2] = x, y else return Spawn[1], Spawn[2] end end,
    seed = function(newSeed) if isNumber(seed) or isString(seed) then Seed = newSeed else return Seed end end,
    worldName = function(name) if isString(name) then WorldName = name else return WorldName end end
}