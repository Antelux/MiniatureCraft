local ScreenWidth, ScreenHeight = Screen.getSize()
local Assets = File.loadAssets()
local menuInterfaces = {}
local interfaces, shapeType = {}, {}
local selected, altSelected, switch = 1, 1, false
local mainFolder = File.getMainDirectory()
local currentSelected, currentList = 1, 1
local offsetX, offsetY = 0, 0
local justOpened = true
local setBackgroundColor, setTextColor, clear, setCursorPos, sWrite, drawScreen, setCursorBlink, getCursorPos = Screen.setBackgroundColor, Screen.setTextColor, Screen.clear, Screen.setCursorPos, Screen.write, Screen.drawScreen, Screen.setCursorBlink, Screen.getCursorPos

--[[
  Conversion of Menu API to Interface API (To do)

  Interace.newInterface(interfaceName, { -- Showing off types of elements
    gui = {{shapeType, isBordered, color, x, y, width, height}},
    text = {{string, backgroundColor, foregroundColor, x, y}},
    button = {{string, backgroundColor, foregroundColor, x, y, functionOnClick}},
    input = {{string, backgroundColor, foregroundColor, x, y, functionOnReturn}},
    animation = string (slideup, slidedown, etc, fadein, fadeout),
    fixed = bool (true if it can't be moved, like the main menu),
    main = function
      -- Basically ran every time the interface is updated. Will be given
      -- eventData in order for more flexibility. 
  })
--]]

local function shortenString(string, n)
  if type(string) ~= "string" then return end
  if string.len(string) <= n then return string end
  
  local nString = ""
  for i = 1, n - 2 do nString = nString .. string.char(string:byte(i)) end
  return nString.. ".."
end

local function splitString(str, sep)
  local sep, result = sep or "%s", {}
  for output in string.gmatch(str, "([^"..sep.."]+)") do result[#result + 1] = output end
  return result
end

-- The following shape-drawing functions are used from the
-- ComputerCraft Graphics Library, Written by Bobby Lucero.
-- Credits to him for this awesome library.

local function Write(x, y, string) setCursorPos(x, y); sWrite(string) end

local function drawBorder(x, y, width, height, bc, tc)
  setBackgroundColor(bc); setTextColor(tc)
  Write(x, y, "+"); Write((x - 1) + width, y, "+")
  Write(x, (y - 1) + height, "+"); Write((x - 1) + width, (y - 1) + height, "+")
  Write(x + 1, y, string.rep("-", width - 2)); Write(x + 1, y + height - 1, string.rep("-", width - 2))
  for i = 1, height - 2 do Write(x, y + i, "|"); Write((x - 1) + width, y + i, "|") end
end

shapeType["pixel"] = function(x1, y1, color)
  paintutils.drawPixel(x1 + offsetX, y1 + offsetY, color)
  --if justOpened and offsetX < x1 then offsetX = -x1 end
end

shapeType["rectangle"] = function(x1, y1, w, h, color, border)
  local x1, y1 = x1 + offsetX, y1 + offsetY
  for i = 1, h do paintutils.drawLine(x1, y1 - 1 + i, x1 + w - 1, y1 - 1 + i, color) end
  if border then drawBorder(x1, y1, w, h, border[1], border[2]) end
  --if justOpened and offsetX < x1 + w then offsetX = -(x1 + w) end
end

shapeType["rectangle:line"] = function(x1, y1, w, h, color, border)
  local x1, y1, w, h = x1 + offsetX, y1 + offsetY, w + offsetX, h + offsetY
  paintutils.drawLine(x1, y1, x1 + w - 1, y1, color)
  paintutils.drawLine(x1, y1 + h - 1, x1 + w - 1, y1 + h - 1, color)
  paintutils.drawLine(x1, y1, x1, y1 + h - 1, color)
  paintutils.drawLine(x1 + w - 1, y1, x1 + w - 1, y1 + h - 1, color)
  if border then drawBorder(x1, y1, w, h, border[1], border[2]) end
  --if justOpened and offsetX < x1 + w then offsetX = -(x1 + w) end
end

_G.Interface = {}

function Interface.newInterface(interfaceName, interfaceElements)
  if type(interfaceName) ~= "string" then return end
  if type(interfaceElements) ~= "table" then return end
  interfaces[interfaceName] = interfaceElements
end

function Interface.getInterfaceData(interfaceName)
  if type(interfaceName) ~= "string" then return end
  if interfaces[interfaceName] then return interfaces[interfaceName] end
end

local function drawLabel(x, y, bc, tc, str)
  setBackgroundColor(bc) setTextColor(tc)
  Chat.writeInColor(str, x, y)
end

function Interface.updateInterface(interfaceName, eventData, playerName)
  if type(interfaceName) ~= "string" then return end
  if not interfaces[interfaceName] then return end
  local interface = interfaces[interfaceName]
  local eventData = eventData or {} 

  --if offsetX < 0 then offsetX = offsetX + 1 end
  if interface.main then 
    if interface.main(eventData) then currentSelected, currentList = 1, 1; justOpened = true; return true end
  end
  
  if interface.gui then
    for k, v in pairs(interface.gui) do
      local element = interface.gui[k]
      if not shapeType[(element.shape or element[1])] or not (element.parameters or element[2]) then return end
      shapeType[element.shape or element[1]](unpack(element.parameters or element[2]))
    end
  end

  if interface.list then
    for k, v in pairs(interface.list) do
      local element = interface.list[k]
      if not (element.table or element[1]) or not (element.x or element[2]) or not (element.y or element[3]) or not (element.width or element[4]) or not (element.height or element[5]) then return end
      local offset, value, bg, fg = -(element.height or element[5]) + currentSelected; if offset < 0 then offset = 0 end
      local cs = k == currentList and currentSelected

      for y = 1, (element.height or element[5]) do
        for x = 1, (element.width or element[4]) do
          value, bg, fg = (element.table or element[1])(playerName, y + offset, cs, x, y)
          if type(value) == "string" then drawLabel((element.x or element[2]) + x - 1 + offsetX, (element.y or element[3]) + y - 1, bg, fg, value) 
          elseif type(value) == "number" then if Assets[value] then drawLabel((element.x or element[2]) + x - 1 + offsetX, (element.y or element[3]) + y - 1, Assets[value].texture[1] or colors.blue, Assets[value].texture[2] or colors.white, Assets[value].texture[3] or " ") end end
        end
      end
    end
  end

  if interface.text then
    for k, v in pairs(interface.text) do
      local element = interface.text[k]
      if not (element.text or element[1]) or not (element.x or element[2]) or not (element.y or element[3]) or not (element.bcolor or element[4]) or not (element.tcolor or element[5]) then return end
      drawLabel((element.x or element[2]) + offsetX, element.y or element[3], element.bcolor or element[4], element.tcolor or element[5], element.text or element[1])
    end
  end

  if interface.button then
    for k, v in pairs(interface.button) do
      local element = interface.button[k]
      if not (element.text or element[1]) or not (element.x or element[2]) or not (element.y or element[3]) or not (element.bcolor or element[4]) or not (element.tcolor or element[5]) or not (element.func or element[6]) then return end
      drawLabel((element.x or element[2]) + offsetX, element.y or element[3], element.bcolor or element[4], element.tcolor or element[5], element.text or element[1])
      if eventData[1] == "mouse_click" then
        if eventData[2] == 1 and eventData[3] >= (element.x or element[2]) and eventData[3] <= #(element.text or element[1]) + (element.x or element[2]) - 1 and eventData[4] == (element.y or element[3]) then
          (element.func or element[6])()
        end
      end
    end
  end

  if interface.input then
    for k, v in pairs(interface.input) do
      local element = interface.input[k]
      --if not interfaces.input[k].currentInput then interfaces.input[k].currentInput = "" end
      if not (element.text or element[1]) or not (element.x or element[2]) or not (element.y or element[3]) or not (element.bcolor or element[4]) or not (element.tcolor or element[5]) or not (element.func or element[6]) then return end
      drawLabel((element.x or element[2]) + offsetX, element.y or element[3], element.bcolor or element[4], element.tcolor or element[5], element.text or element[1])
      if eventData[1] == "mouse_click" then
        if eventData[2] == 1 and eventData[3] >= (element.x or element[2]) and eventData[3] <= #(element.text or element[1]) + (element.x or element[2]) - 1 and eventData[4] == (element.y or element[3]) then
          
        end
      end
    end
  end

  local element = interface.list[currentList] or interface.list[1]; local maxEntries = (element.table or element[1])(playerName, "getMaxEntries") or 1
  if currentSelected < 1 then currentSelected = maxEntries end; if currentSelected > maxEntries then currentSelected = 1 end
  if currentList < 1 then currentList = #interface.list end; if currentList > #interface.list then currentList = 1 end
  if eventData[1] == "key" then
    if eventData[2] == 17 or eventData[2] == 200 then currentSelected = currentSelected - 1 end -- Up key
    if eventData[2] == 31 or eventData[2] == 208 then currentSelected = currentSelected + 1 end -- Down key
    if eventData[2] == 30 or eventData[2] == 203 then currentList = currentList - 1 end -- left key
    if eventData[2] == 32 or eventData[2] == 205 then currentList = currentList + 1 end -- Right key
    if eventData[2] == keys.enter then local exitFunction = (element.exit or element[6]) or function() end; exitFunction(playerName, currentSelected) end
  elseif eventData[1] == "mouse_scroll" then currentSelected = currentSelected + eventData[2] end

  if eventData[1] == "key" then
    if interface.escapeKeys then
      for key, value in pairs(interface.escapeKeys) do if eventData[2] == value then currentSelected = 1; justOpened = true; offsetX = 0; return true end end
    elseif eventData[2] == keys.e then currentSelected, currentList = 1, 1; justOpened = true; offsetX = 0; return true end
  end

  --if justOpened then justOpened = false end
end

function Interface.modifyInterface(interfaceName, parameters)

end

-- Make the menus drag-able; That would be awesome. Have an option to have it stuck or not.

local function openInventory(playerName, entry, selected, x, y)
  local playerInventory = Player.getInventory(playerName)
  if entry == "getMaxEntries" then return #playerInventory end
  if not playerInventory[entry] then return end
  --local textColor = Assets[playerInventory[entry].ID].texture[2] or colors.white
  if x == 1 then 
    if entry == selected then return "[" ..shortenString(Assets[playerInventory[entry].ID].name, 9).. "]", colors.blue, colors.white
    else return shortenString(Assets[playerInventory[entry].ID].name, 9), colors.blue, colors.lightGray end
    -- Colorful version; Experimental
    --if entry == selected then return "&f[" ..Chat.convertToColorCode(textColor).. "" ..shortenString(Assets[playerInventory[entry].ID].name, 9).. "&f]", colors.blue, colors.white 
    --else return Chat.convertToColorCode(textColor).. "" ..shortenString(Assets[playerInventory[entry].ID].name, 9), colors.blue, colors.lightGray end
  elseif x == 13 then return playerInventory[entry].ID
  elseif x == 14 then return "x" ..playerInventory[entry].Amount, colors.blue, colors.lightGray end
end

local function openChest(playerName, entry, selected, x, y)
  local playerInventory = Player.getInventory(playerName)
  local interactionCoordsX, interactionCoordsY = Player.getFacingCoords(playerName)
  local Chest = Level.getData(Player.getDimension(playerName), interactionCoordsX, interactionCoordsY).Block or false
  if not Chest or not Assets[Chest.ID].inventory then return end; Chest.storage = Chest.storage or {}
  if entry == "getMaxEntries" then return #Chest.storage end
  if not Chest.storage[entry] then return end
  if x == 1 then 
    if entry == selected then return "[" ..shortenString(Assets[Chest.storage[entry].ID].name, 9).. "]", colors.blue, colors.white
    else return shortenString(Assets[Chest.storage[entry].ID].name, 9), colors.blue, colors.lightGray end
  elseif x == 13 then return Chest.storage[entry].ID
  elseif x == 14 then return "x" ..Chest.storage[entry].Amount, colors.blue, colors.lightGray end
end

local function equipItem(playerName, selected)
  local playerInventory = Player.getInventory(playerName)
  local interactionCoordsX, interactionCoordsY = Player.getFacingCoords(playerName)
  local Chest = Level.getData(Player.getDimension(playerName), interactionCoordsX, interactionCoordsY).Block or false
  if not Chest or not Chest.ID or not Assets[Chest.ID].inventory then  
    local playerInventory = Player.getInventory(playerName)
    if not playerInventory[selected] then return end
    Player.equipItem(playerName, selected)
  else
    Chest.storage = Chest.storage or {}
    if #Chest.storage >= Assets[Chest.ID].inventory then return end
    Chest.storage[#Chest.storage + 1] = playerInventory[selected]
    table.remove(playerInventory, selected)
    Player.setInventory(playerName, playerInventory)
  end
end

local function switchItem(playerName, selected)
  local playerInventory = Player.getInventory(playerName)
  local interactionCoordsX, interactionCoordsY = Player.getFacingCoords(playerName)
  local Chest = Level.getData(Player.getDimension(playerName), interactionCoordsX, interactionCoordsY).Block or false
  if not Chest or not Assets[Chest.ID].inventory then return end; Chest.storage = Chest.storage or {}; if not Chest.storage[selected] then return end
  playerInventory[#playerInventory + 1] = Chest.storage[selected]
  table.remove(Chest.storage, selected)
  Player.setInventory(playerName, playerInventory)
end

Interface.newInterface("Inventory", { -- What the inventory interface could look like
  gui = {{"rectangle", {2, 4, 18, 14, colors.blue, {colors.blue, colors.white}}}},
  text = {{"INVENTORY", 3, 4, colors.blue, colors.yellow}},
  list = {{openInventory, 3, 5, 16, 12, equipItem}}--,
  --animation = "slideinright"
})

Interface.newInterface("Chest", { -- What the chest interface could look like
  gui = {{"rectangle", {2, 4, 18, 14, colors.blue, {colors.blue, colors.white}}}, {"rectangle", {22, 4, 18, 14, colors.blue, {colors.blue, colors.white}}}},
  text = {{"INVENTORY", 4, 4, colors.blue, colors.yellow}, {"CHEST", 24, 4, colors.blue, colors.yellow}},
  list = {{openInventory, 3, 5, 16, 12, equipItem}, {openChest, 23, 5, 16, 12, switchItem}}
})

_G.Menu = {}

function Menu.Write(x, y, string) setCursorPos(x, y); sWrite(string) end
function Menu.drawMenuBox(x, y, width, height, title, backgroundColor, borderColor, titleColor)
  local backgroundColor = backgroundColor or colors.blue
  local borderColor = borderColor or colors.white
  local titleColor = titleColor or colors.yellow

  for i = 1, height - 2 do paintutils.drawLine(x + 1, y + i, x + width - 2, y + i, backgroundColor) end

  setTextColor(borderColor)
  Menu.Write(x, y, "+"); Menu.Write((x - 1) + width, y, "+")
  Menu.Write(x, (y - 1) + height, "+"); Menu.Write((x - 1) + width, (y - 1) + height, "+")

  for i = 1, height - 2 do Menu.Write(x, y + i, "|"); Menu.Write((x - 1) + width, y + i, "|") end
  for i = 1, width - 2 do Menu.Write(x + i, y, "-"); Menu.Write(x + i, (y - 1) + height, "-") end
  if title then setTextColor(titleColor); Menu.Write(x + 2, y, title) end
end

local function menuList(x, y, width, height, title, table, selection)
  Menu.drawMenuBox(x, y, width, height, title)

  local returnValue = false
  for i = 1 + (selection - 1), height - 2  + (selection - 1) do
    if table[i] then
      setBackgroundColor(colors.blue)
      setTextColor(colors.lightGray)
      setCursorPos(x + 2, y + (i - selection + 1))

      if i == selection then print("[" ..shortenString(Assets[table[i].ID].name, 7).. "]"); returnValue = i
      else print(shortenString(Assets[table[i].ID].name, 7)) end
      
      Menu.Write(x + 11, y + (i - selection + 1), "x" ..table[i].Amount)
      setCursorPos(x + 15, y + (i - selection + 1))
      if Assets[table[i].ID].type == "block" or Assets[table[i].ID].type == "blocktile" or Assets[table[i].ID].type == "tile" or Assets[table[i].ID].type == "liquid" then
        setBackgroundColor(Assets[table[i].ID].texture[1] or colors.blue)
        setTextColor(Assets[table[i].ID].texture[2] or colors.white)
        sWrite(Assets[table[i].ID].texture[3] or "?")
      else
        setTextColor(Assets[table[i].ID].texture[1])
        sWrite(Assets[table[i].ID].texture[2])
      end
    else break end
  end

  return returnValue
end

local function translateKey(key, value, maxValue, manual)
  if not manual then
    if key == 17 or key == 200 then value = value - 1 end -- Up Key
    if key == 31 or key == 208 then value = value + 1 end -- Down Key
  else value = value + manual end
  if maxValue and value < 1 then value = maxValue end
  if maxValue and value > maxValue then value = 1 end
  return value
end

local nString, history = "",  {}
local function newRead(eventData, x, y, maxWidth)
  if not eventData then return end
  local maxWidth = maxWidth or 100

  if eventData[1] == "char" then if #nString < maxWidth then nString = nString.. eventData[2]; end 
  elseif eventData[1] == "key" then
    if eventData[2] == 14 then nString = string.sub(nString, 1, #nString - 1);  
    elseif eventData[2] == 28 then setCursorBlink(false); local t = nString; nString = ""; return t end
  end

  setBackgroundColor(colors.gray)
  setTextColor(colors.white)
  setCursorPos(x, y)
  sWrite(nString)
  setCursorBlink(true)
end

function Menu.newInterface(interfaceName, newInterface)
  if type(interfaceName) ~= "string" or type(newInterface) ~= "function" then return end; menuInterfaces[interfaceName] = newInterface
end

function Menu.getInterface(interfaceName)
  return type(interfaceName) == "string" and menuInterfaces[interfaceName] 
end

local function openCraftingInterface(eventData, currentPlayer)
  local interactionCoords = {Player.getFacingCoords(currentPlayer)}
  local Block = Level.getData(Player.getDimension(currentPlayer), interactionCoords[1], interactionCoords[2]).Block
  local craftingTables = Crafting.getCraftingTables()
  local tableID = Crafting.isCraftingTable(Block.ID)
  local x, y, width, height = craftingTables[tableID].Size[1], craftingTables[tableID].Size[2], craftingTables[tableID].Size[3], craftingTables[tableID].Size[4]

  if pocket then width = width - 6 end
  Menu.drawMenuBox(x, y, width, height, craftingTables[tableID].Name)
  Menu.drawMenuBox(width + 3, y, width, (height / 2) - 4, "HAVE")
  Menu.drawMenuBox(width + 3, (y + height / 2) - 3, width, (height / 2) + 3, "REQUIRED")

  if eventData[1] == "key" then 
    selected = translateKey(eventData[2], selected, #craftingTables[tableID].Recipes)
    if eventData[2] == 16 or eventData[2] == 18 then selected = 1; return true -- Q, E
    elseif eventData[2] == 28 then -- Enter 
      if Player.getMode(currentPlayer) == 0 then
        for i = 1, #craftingTables[tableID].Recipes[selected].Input / 2 do
          local _, amountHave = Player.checkInventory(currentPlayer, craftingTables[tableID].Recipes[selected].Input[(i * 2) - 1]) 
          if not amountHave or amountHave < craftingTables[tableID].Recipes[selected].Input[i * 2] then return end
        end

        for i = 1, #craftingTables[tableID].Recipes[selected].Input / 2 do
          local giveID = craftingTables[tableID].Recipes[selected].Input[(i * 2) - 1]
          local giveAmount = craftingTables[tableID].Recipes[selected].Input[i * 2]
          if giveID and giveAmount then Player.removeItem(currentPlayer, giveID, giveAmount) end
        end
        Player.giveItem(currentPlayer, craftingTables[tableID].Recipes[selected].Output[1], craftingTables[tableID].Recipes[selected].Output[2])
      else Player.giveItem(currentPlayer, craftingTables[tableID].Recipes[selected].Output[1], craftingTables[tableID].Recipes[selected].Output[2]) end
    end
  end

  for i = 1 + (selected - 1), height - 2 + (selected - 1) do
    setCursorPos(x + 1, y + (i - selected) + 1)
    if craftingTables[tableID].Recipes[i] then 
      local assetName = Level.convertID(craftingTables[tableID].Recipes[i].Output[1])
      if type(assetName) ~= "string" then return end; setBackgroundColor(colors.blue)
      if i == selected then setTextColor(colors.white); sWrite("[" ..shortenString(assetName, width - 7).. "]") else setTextColor(colors.lightGray); sWrite(shortenString(assetName, width - 7)) end
      setCursorPos(width - 1, y + (i - selected) + 1)
      setBackgroundColor(Assets[craftingTables[tableID].Recipes[i].Output[1]].texture[1] or 0)
      setTextColor(Assets[craftingTables[tableID].Recipes[i].Output[1]].texture[2] or colors.white)
      sWrite(Assets[craftingTables[tableID].Recipes[i].Output[1]].texture[3] or " ")
    end
  end

  setBackgroundColor(colors.blue); setTextColor(colors.lightGray)
  if not craftingTables[tableID].Recipes[selected].Input then return end
  for i = 1, #craftingTables[tableID].Recipes[selected].Input / 2 do
    local slot, amountHave = Player.checkInventory(currentPlayer, craftingTables[tableID].Recipes[selected].Input[(i * 2) - 1])
    if (Player.getMode(currentPlayer) == 0 and amountHave and amountHave >= craftingTables[tableID].Recipes[selected].Input[i * 2]) or Player.getMode(currentPlayer) == 1 then setTextColor(colors.lightGray) else setTextColor(colors.gray) end
    Menu.Write(width * 2 - 1, y + 4 + i, "x" ..craftingTables[tableID].Recipes[selected].Input[i * 2])
    Menu.Write(width + 4, y + 4 + i, shortenString(Level.convertID(craftingTables[tableID].Recipes[selected].Input[(i * 2) - 1]) or "Unknown", width - 4))
  end

  local _, amountHave = Player.checkInventory(currentPlayer, craftingTables[tableID].Recipes[selected].Output[1]); amountHave = amountHave or 0
  if amountHave ~= 0 then setTextColor(colors.lightGray) else setTextColor(colors.gray) end
  local stackSize = Assets[craftingTables[tableID].Recipes[selected].Output[1]].maxStack or 99
  local totalStacks = math.floor(amountHave / stackSize); local leftover = amountHave - (stackSize * totalStacks); local totalAmount = ""
  if totalStacks == 0 then totalAmount = tostring(leftover) else totalAmount = tostring(totalStacks).. "x" ..tostring(stackSize).. " + " ..tostring(leftover).. " (" ..amountHave.. ")" end
  setCursorPos(width + 12 - (#totalAmount / 2), y + 1); sWrite(totalAmount)
end

local function fadeWrite(text, colorTable)
  local text = tostring(text)
  local colorTable = colorTable or {colors.black, colors.gray, colors.lightGray, colors.white}
  local cx, cy = getCursorPos()

  for i = 1, #text do
    setCursorPos(cx, cy); setTextColor(colorTable[4]); sWrite(string.sub(text, 1, i))
    setCursorPos(cx + (i - 1) + 1, cy); setTextColor(colorTable[3]); sWrite(string.sub(text, i + 1, i + 1))
    setCursorPos(cx + (i - 1) + 2, cy); setTextColor(colorTable[2]); sWrite(string.sub(text, i + 2, i + 2))
    setCursorPos(cx + (i - 1) + 3, cy); setTextColor(colorTable[1]); sWrite(string.sub(text, i + 3, i + 3))
    coroutine.yield()
  end

  while true do
    setCursorPos(cx, cy); setTextColor(colorTable[4]); sWrite(string.sub(text, 1, i))
    coroutine.yield()
  end
end

local coroutines = {}
local function addFadeText(sec, str, c, x, y)
  coroutines[sec] = coroutine.create(function() setCursorPos(x, y); fadeWrite(str, c) end)
end

local function removeButtons(str)
  for k, v in pairs(coroutines) do
    if string.find(k, str) then coroutines[k] = nil end
  end
end

local textColors = {
  [1] = {{32768, 128, 256, 256}, {32768, 32768, 128, 128}},
  [0] = {{32768, 128, 256, 1}, {32768, 128, 256, 1}},
  [-1] = {{32768, 1024, 4, 4}, {32768, 128, 256, 1}},
  [-2] = {{4096, 16384, 16, 16}, {32768, 128, 256, 1}},
  [-3] = {{128, 2048, 512, 8}, {32768, 128, 256, 1}}
}

local function addServerText(dim)
  addFadeText("servertitle", "Server List", textColors[dim][1], (ScreenWidth / 2) - 5.5, 5)
  addFadeText("serverbutton1", "Create", textColors[dim][1], (ScreenWidth / 2) - 3 - 3, ScreenHeight - 2)
  addFadeText("serverbutton2", "Back", textColors[dim][1], (ScreenWidth / 2) - 2 + 4, ScreenHeight - 2)
  local modem = false
  for k, v in ipairs(peripheral.getNames()) do
    if peripheral.getType(v) == "modem" then
      modem = true; break
    end
  end
  if not modem then addFadeText("serverwarning", "Warning: No Modem Found.", {colors.black, colors.gray, colors.brown, colors.red}, 1, ScreenHeight) end
end 

local serverList = File.getServerList()
local viewingList = true
local sTitle = false
local function serverMenu(eventData, dim) 
  if not eventData then return end; if not sTitle then addServerText(dim); sTitle = true end
  local offset = 0

  if viewingList then
    local listOffset = #serverList - 7
    if listOffset < 0 then listOffset = 0 end

    setTextColor(textColors[dim][2][4])
    for i = 1 + listOffset, 7 + listOffset do
      if serverList[i] then
        local serverName = serverList[i][1].. " - " ..serverList[i][2].. ":" ..serverList[i][3]
        Menu.Write(((ScreenWidth - 11) / 2) + offset - (#serverName / 4), 6 + i - listOffset, serverName)
      end
    end
  else

    
  end

  if eventData[1] == "mouse_click" then 
    if eventData[3] > 26 and eventData[3] < 31 and eventData[4] == ScreenHeight - 2 then removeButtons("server"); sTitle = false return true
    elseif eventData[3] > 18 and eventData[3] < 25 and eventData[4] == ScreenHeight - 2 then -- Create

    end
  end
end

local function timeoutMenu(eventData) 
end

local function addModButtons(dim)
  addFadeText("modstitle", "Mods", textColors[dim][1], (ScreenWidth / 2) - 2, 5)
  addFadeText("modsbutton", "Back", textColors[dim][1], (ScreenWidth / 2) - 2, ScreenHeight - 2)
end

local modsbutton = false
local function modsMenu(eventData, dim) 
  if not modsbutton then addModButtons(dim); modsbutton = true end
  if eventData[1] == "mouse_click" then
    if eventData[3] > 22 and eventData[3] < 27 and eventData[4] == ScreenHeight - 2 then removeButtons("mods"); modsbutton = false return true end      
  end
end

local isReading = false
local button = false

local function addOptionButtons(dim)
  addFadeText("optiontitle", "Options", textColors[dim][1], (ScreenWidth / 2) - 3.5, 5)
  addFadeText("optionbutton", "Back", textColors[dim][1], (ScreenWidth / 2) - 2, ScreenHeight - 2)
end

local function optionsMenu(eventData, dim) 
  if not button then addOptionButtons(dim); button = true end
  if eventData[1] == "mouse_click" and not isReading then
    if eventData[3] >= ((ScreenWidth - 12) / 2) and eventData[3] <= ((ScreenWidth - 12) / 2) + 16 and eventData[4] == 9 then
      File.setCurrentColor(2 ^ (eventData[3] - math.floor((ScreenWidth - 12) / 2) - 1))
    elseif eventData[3] >= ((ScreenWidth - 12) / 2) and eventData[3] <= ((ScreenWidth - 12) / 2) + 16 and eventData[4] == 8 then
      paintutils.drawLine(((ScreenWidth - 12) / 2) - 4, 8, ((ScreenWidth - 12) / 2) + 11, 8, colors.gray); isReading = true
    elseif eventData[3] > 22 and eventData[3] < 27 and eventData[4] == ScreenHeight - 2 then removeButtons("option"); button = false return true end      
  end
    
  local playerName = File.getCurrentPlayer()
  local playerColor = File.getCurrentColor()

  setBackgroundColor(0); setTextColor(textColors[dim][2][4])
  Menu.Write((ScreenWidth / 2) - 11, 8, "Name:"); Menu.Write((ScreenWidth / 2) - 11, 9, "Color:")
  paintutils.drawLine((ScreenWidth / 2) - 5, 8, (ScreenWidth / 2) + 10, 8, colors.gray)
  if isReading then setTextColor(colors.white) else setTextColor(colors.lightGray) end
  if not isReading then Menu.Write((ScreenWidth / 2) - 5, 8, playerName) end
  for i = 1, 16 do
    setBackgroundColor(2 ^ (i - 1))
    if playerColor == 1 then setTextColor(colors.black) else setTextColor(colors.white) end
    if 2 ^ (i - 1) == playerColor then Menu.Write((ScreenWidth / 2) - 6 + i, 9, "X")
    else Menu.Write((ScreenWidth / 2) - 6 + i, 9, " ") end
  end

  if isReading then
    local name = newRead(eventData, (ScreenWidth / 2) - 5, 8, 16)
    if name then File.setCurrentPlayer(name); isReading = false end
  end
  setBackgroundColor(0)
end

local pauseChoices = {"Resume", "Save & Quit"}
local function pauseMenu(eventData)
  Level.pause(true)
  if eventData[1] == "key" then
    selected = translateKey(eventData[2], selected, #pauseChoices)
    if eventData[2] == 28 then if selected == 1 then Level.pause(false); return true else selected = 1; Level.pause(false); return "quit" end
    elseif eventData[2] == 14 then selected = 1; Level.pause(false); return true end
  end

  local offset = 0; if pocket then offset = 2 end
  Menu.drawMenuBox(math.floor(ScreenWidth / 4), math.floor(ScreenHeight / 2) - 1, math.ceil(ScreenWidth / 2) + offset, 4, "PAUSED")
  setTextColor(colors.lightGray)
  for i = 1, #pauseChoices do
    if i == selected then Menu.Write(math.floor(ScreenWidth / 4) + 1, math.floor(ScreenHeight / 2) + i - 1, "[" ..pauseChoices[i].. "]")
    else Menu.Write(math.floor(ScreenWidth / 4) + 2, math.floor(ScreenHeight / 2) + i - 1, pauseChoices[i]) end
  end
end


local createNewWorld = false
local worldName = "World"
local shouldRead = false
local fileList

local function getSaves()
  fileList = fs.list(mainFolder.. "/Saves")
  for i = 1, #fileList do
    if type(fileList[i]) ~= "string" or not fs.isDir(mainFolder.. "/Saves/" ..fileList[i]) or not fs.exists(mainFolder.. "/Saves/" ..fileList[i].. "/world.data") or not fs.isDir(mainFolder.. "/Saves/" ..fileList[i].. "/Dimension") then
      table.remove(fileList, i) 
    end
  end
end
getSaves()

local function addLevelText(dim)
  addFadeText("leveltitle", "Select World", textColors[dim][1], (ScreenWidth / 2) - 6, 5)
  addFadeText("levelbutton1", "Create", textColors[dim][1], (ScreenWidth / 2) - 3 - 3, ScreenHeight - 2)
  addFadeText("levelbutton2", "Back", textColors[dim][1], (ScreenWidth / 2) - 2 + 4, ScreenHeight - 2)
end

local function addLevelText2(dim)
  removeButtons("leveltitle")
  addFadeText("leveltitle", "Create World", textColors[dim][1], (ScreenWidth / 2) - 6, 5)
  addFadeText("levelsize", "Select Size", textColors[dim][1], (ScreenWidth / 2) - 5.5, 12)
end

local title = false
local selectedWorld = false
local selectedSize = 1
local sizes = {{"64x64", (ScreenWidth / 2) - 9, 64}, {"128x128", (ScreenWidth / 2) - 3.5, 128}, {"256x256", (ScreenWidth / 2) + 5, 256}}
local seed = ""
local isReadingWorld = false
local isReadingSeed = false

local function levelMenu(eventData, dim)
  if not eventData then return end; if not title then addLevelText(dim); title = true end
  if not createNewWorld then
    getSaves()
    for i = 1, #fileList do
      if selectedWorld and fileList[i] == selectedWorld then setTextColor(textColors[dim][1][4] == textColors[dim][2][4] and colors.lightGray or textColors[dim][1][4]) else setTextColor(textColors[dim][2][4]) end
      setCursorPos((ScreenWidth / 2) - (#fileList[i] / 2), 6 + i)
      sWrite(fileList[i])
    end
  else
    setTextColor(textColors[dim][2][4])
    Write((ScreenWidth / 2) - 11, 8, "Name:"); Menu.Write((ScreenWidth / 2) - 11, 10, "Seed:")
    for i = 0, 2, 2 do paintutils.drawLine((ScreenWidth / 2) - 5, 8 + i, (ScreenWidth / 2) + 10, 8 + i, colors.gray) end
    Write((ScreenWidth / 2) - 5, 8, worldName); Write((ScreenWidth / 2) - 5, 10, seed); setBackgroundColor(0)
    for i = 1, 3 do
      if i == selectedSize then setTextColor(textColors[dim][1][4] ~= textColors[dim][2][4] and textColors[dim][1][4] or colors.gray) else setTextColor(textColors[dim][2][4]) end
      Write(sizes[i][2], 13, sizes[i][1])
    end
  end

  if eventData[1] == "mouse_click" and not isReadingWorld and not isReadingSeed then
    if not createNewWorld then
      if eventData[3] > 26 and eventData[3] < 31 and eventData[4] == ScreenHeight - 2 then removeButtons("level"); title = false; selectedSize = 1; return true
      elseif eventData[3] > 18 and eventData[3] < 25 and eventData[4] == ScreenHeight - 2 then createNewWorld = true; addLevelText2(dim) end
      for i = 1, #fileList do
        if eventData[3] >= (ScreenWidth / 2) - (#fileList[i] / 2) and eventData[3] <= (ScreenWidth / 2) - (#fileList[i] / 2) + #fileList[i] and eventData[4] == 6 + i then
          File.loadWorld(fileList[i]); removeButtons("level"); title = false; return "singlePlayer"
        end
      end
    else
      if eventData[3] > 26 and eventData[3] < 31 and eventData[4] == ScreenHeight - 2 then createNewWorld = false; selectedSize = 1; removeButtons("leveltitle"); removeButtons("levelsize"); addFadeText("leveltitle", "Select World", textColors[dim][1], (ScreenWidth / 2) - 6, 5) 
      elseif eventData[3] >= (ScreenWidth / 2) - 9 and eventData[3] <= (ScreenWidth / 2) - 5 and eventData[4] == 13 then selectedSize = 1
      elseif eventData[3] >= (ScreenWidth / 2) - 3.5 and eventData[3] <= (ScreenWidth / 2) + 3.5 and eventData[4] == 13 then selectedSize = 2
      elseif eventData[3] >= (ScreenWidth / 2) + 5 and eventData[3] <= (ScreenWidth / 2) + 11 and eventData[4] == 13 then selectedSize = 3
      elseif eventData[3] >= (ScreenWidth / 2) - 5 and eventData[3] <= (ScreenWidth / 2) + 11 and eventData[4] == 8 then isReadingWorld = true -- Clicking on name 
      elseif eventData[3] >= (ScreenWidth / 2) - 5 and eventData[3] <= (ScreenWidth / 2) + 11 and eventData[4] == 10 then isReadingSeed = true -- Clicking on seed
      elseif eventData[3] > 18 and eventData[3] < 25 and eventData[4] == ScreenHeight - 2 then 
        local currentWorld = Level.getWorld()
        Level.setSeed(seed ~= "" and seed)
        Level.setWorld(Level.newWorld(sizes[selectedSize][3], sizes[selectedSize][3]))
        local currentPlayer = Player.getCurrentPlayer()
        Player.newPlayer(currentPlayer)
        Player.giveItem(currentPlayer, 150, 1) -- Punch Item
        Player.giveItem(currentPlayer, 13, 1) -- Crafting Table
        Player.giveItem(currentPlayer, 210, 3) -- Apple
        while true do
          local rx, ry = math.random(64), math.random(64)
          local Data = Level.getData(0, rx, ry)
          if not (Data.Block and Data.Block.ID) and Data.Tile and Data.Tile.ID and Data.Tile.ID == 50 then 
            Player.setCoordinates(currentPlayer, rx, ry); Level.setSpawnPoint({rx, ry})
          break end
        end
        -- why must I become lazy....
        for i = 1, 20 do
          while true do
            local rx, ry = math.random(64), math.random(64)
            local Data = Level.getData(0, rx, ry)
            if not (Data.Block and Data.Block.ID) and Data.Tile and Data.Tile.ID and Data.Tile.ID == 50 then 
              Entity.spawnEntity(math.random(450, 452), 0, rx, ry)
            break end
          end
          while true do
            local rx, ry = math.random(64), math.random(64)
            local Data = Level.getData(-1, rx, ry)
            if not (Data.Block and Data.Block.ID) and Data.Tile and Data.Tile.ID and Data.Tile.ID == 55 then 
              Entity.spawnEntity(math.random(400, 402), -1, rx, ry)
            break end
          end
          while true do
            local rx, ry = math.random(64), math.random(64)
            local Data = Level.getData(-2, rx, ry)
            if not (Data.Block and Data.Block.ID) and Data.Tile and Data.Tile.ID and Data.Tile.ID == 67 then 
              Entity.spawnEntity(math.random(400, 402), -2, rx, ry)
            break end
          end
          while true do
            local rx, ry = math.random(64), math.random(64)
            local Data = Level.getData(-3, rx, ry)
            if not (Data.Block and Data.Block.ID) and Data.Tile and Data.Tile.ID and Data.Tile.ID == 67 then 
              Entity.spawnEntity(math.random(400, 402), -3, rx, ry)
            break end
          end
        end
        File.saveWorld(worldName); Level.setWorld(currentWorld); Player.setPlayers({}); Entity.setEntities({}); selectedSize = 1; seed = ""; worldName = "World"
        createNewWorld = false; removeButtons("leveltitle"); removeButtons("levelsize"); addFadeText("leveltitle", "Select World", textColors[dim][1], (ScreenWidth / 2) - 6, 5) 
      end
    end
  end

  if isReadingWorld then
    worldName = newRead(eventData, (ScreenWidth / 2) - 5, 8, 16) or ""
    if worldName and worldName ~= "" then isReadingWorld = false end
  elseif isReadingSeed then
    seed = newRead(eventData, (ScreenWidth / 2) - 5, 10, 16) or ""
    if seed and seed ~= "" then isReadingSeed = false end
  end
  setBackgroundColor(0)
end

local screenText = false
local function addScreenText(dim, otherText)
  if screenText and not otherText then return end
  if not otherText then
    local titleString = "MiniatureCraft " ..File.getVersion() 
    addFadeText("title", titleString, textColors[dim][1], math.ceil((ScreenWidth / 2) - (#titleString / 2)), 3)
  end
  addFadeText("titlebutton1", "Singleplayer", textColors[dim][2], 5, ScreenHeight)
  addFadeText("titlebutton2", "Multiplayer", textColors[dim][2], 4, ScreenHeight - 2)
  addFadeText("titlebutton3", "Options", textColors[dim][2], 3, ScreenHeight - 4)
  addFadeText("titlebutton4", "Mods", textColors[dim][2], 2, ScreenHeight - 6)
  addFadeText("titlebutton5", "Quit", textColors[dim][2], 1, ScreenHeight - 8)
  screenText = true
end

local offsets = {}
local reverse = false
local currentMenu = false
local buttons = {levelMenu, serverMenu, optionsMenu, modsMenu, "quit"}
local function openStartInterface(eventData, dim)
  if not eventData then return end; setBackgroundColor(0); addScreenText(dim)
  if not currentMenu then
    if eventData[1] == "mouse_click" and eventData[2] == 1 then
      if eventData[3] > 0 and eventData[3] < 5 and eventData[4] == ScreenHeight - 8 then currentMenu = "quit"; removeButtons("titlebutton")
      elseif eventData[3] > 1 and eventData[3] < 6 and eventData[4] == ScreenHeight - 6 then currentMenu = modsMenu; removeButtons("titlebutton")
      elseif eventData[3] > 2 and eventData[3] < 10 and eventData[4] == ScreenHeight - 4 then currentMenu = optionsMenu; removeButtons("titlebutton")
      elseif eventData[3] > 3 and eventData[3] < 16 and eventData[4] == ScreenHeight - 2 then currentMenu = serverMenu; removeButtons("titlebutton")
      elseif eventData[3] > 4 and eventData[3] < 19 and eventData[4] == ScreenHeight then currentMenu = levelMenu; removeButtons("titlebutton") end
    end
  elseif type(currentMenu) == "function" then 
    local action = currentMenu(eventData, dim) 
    if action then 
      currentMenu = false; addScreenText(dim, true)
      if type(action) == "string" then return action end 
    end
  elseif type(currentMenu) == "string" and currentMenu == "quit" then 
    Screen.setBackgroundColor(colors.black); Screen.setTextColor(colors.yellow)
    Screen.clear(); Screen.setCursorPos(1, 1); print("Thanks for playing MiniatureCraft by Detective_Smith!") 
    Screen.setTextColor(colors.white); Screen.drawScreen()
    _G.error = nativeError; _G.nativeError = nil; _G.printError = nativePrintError; _G.nativePrintError = nil
    _G.Level = {}; _G.Player = {}; _G.File = {}; _G.Crafting = {}; _G.Chat = {}; _G.Entity = {}; _G.Buffer = {}; _G.Screen = {};
  end

  if eventData[1] ~= "key" and eventData[1] ~= "char" and eventData[1] ~= "mouse_scroll" and eventData[1] ~= "mouse_drag" then
    for k, v in pairs(coroutines) do
      if type(coroutines[k]) == "thread" and coroutine.status(coroutines[k]) ~= "dead" then
        coroutine.resume(coroutines[k])
      else coroutines[k] = nil end
    end
  end
end

local function changeBlock(playerName, newID)
  local interactionCoordsX, interactionCoordsY = Player.getFacingCoords(playerName)
  local doorBlock = Level.getData(Player.getDimension(playerName), interactionCoordsX, interactionCoordsY).Block or false
  if not doorBlock then return end; Level.setData(Player.getDimension(playerName), interactionCoordsX, interactionCoordsY, {Block = {ID = newID}})
end

local tString, tHistory, mouseScroll, chatScroll = "", {}, 0, 0
local function chatInterface(eventData, playerName)
  local chatHistory = Chat.getMessages()
  local scrollOffset = math.floor(-(ScreenHeight / 2) + #chatHistory + 1); if scrollOffset < 0 then scrollOffset = 0 end

  setCursorBlink(true)
  if eventData[1] == "char" then if #tString < ScreenWidth then tString = tString.. eventData[2]; end 
  elseif eventData[1] == "key" then
    if eventData[2] == 14 then tString = string.sub(tString, 1, #tString - 1);  
    elseif eventData[2] == 28 then Chat.sendMessage(tString, playerName); tHistory[#tHistory + 1] = tString; chatScroll = #tHistory; tString = "" 
    elseif eventData[2] == 59 then tString = ""; setCursorBlink(false); return true 
    elseif eventData[2] == 200 then chatScroll = chatScroll - 1; if chatScroll < 0 then chatScroll = 0 end; tString = tHistory[chatScroll + 1] or tString
    elseif eventData[2] == 208 then chatScroll = chatScroll + 1; if chatScroll > #tHistory then chatScroll = #tHistory end; tString = tHistory[chatScroll + 1] or tString end
  elseif eventData[1] == "mouse_scroll" then
    mouseScroll = mouseScroll + eventData[2]
    if mouseScroll + scrollOffset > #chatHistory + math.floor(-(ScreenHeight / 2)) then mouseScroll = 0 end
    if mouseScroll + scrollOffset < -(#chatHistory) then mouseScroll = -(#chatHistory) end
  end
  setCursorPos(1, 1); setTextColor(colors.black); setBackgroundColor(0); sWrite("MS: " ..mouseScroll.. " / #C: " ..#chatHistory)

  for i = 1, ScreenHeight / 2 do paintutils.drawLine(1, ScreenHeight - i, ScreenWidth / 2, ScreenHeight - i, colors.gray) end
  setBackgroundColor(0); setTextColor(colors.white)
  for i = 1, ScreenHeight / 2 do if chatHistory[i + mouseScroll + scrollOffset] then Chat.writeInColor(chatHistory[i + mouseScroll + scrollOffset][1], 1, ScreenHeight + i - (ScreenHeight / 2)) end end
  paintutils.drawLine(1, ScreenHeight, ScreenWidth / 2, ScreenHeight, colors.lightGray); setTextColor(colors.white)
  setCursorPos(1, ScreenHeight); if #tString <= (ScreenWidth / 2) - 2 then sWrite(tString) 
  else sWrite(string.sub(tString, 1 + (#tString - ((ScreenWidth / 2) - 2)))) end
end

Menu.newInterface("Crafting", openCraftingInterface)
--Menu.newInterface("Inventory", openInventoryInterface)
Menu.newInterface("Chest", openChestInterface)
Menu.newInterface("StartMenu", openStartInterface)
Menu.newInterface("DoorOpen", function(eventData, playerName) changeBlock(playerName, 34); while true do if eventData then return true end end end)
Menu.newInterface("DoorClosed", function(eventData, playerName) changeBlock(playerName, 35); while true do if eventData then return true end end end)
Menu.newInterface("Chat", chatInterface)
Menu.newInterface("PauseMenu", pauseMenu)