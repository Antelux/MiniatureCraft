local ScreenWidth, ScreenHeight = Screen.getSize()
local Assets = File.loadAssets()
local menuInterfaces = {}
local interfaces, shapeType = {}, {}
local selected, altSelected, switch = 1, 1, false
local mainFolder = File.getMainDirectory()
local currentSelected, currentList = 1, 1
local offsetX, offsetY = 0, 0
local justOpened = true

--[[
  Conversion of Menu API to Interface API (To do)

  Interace.newInterface(interfaceName, { -- Showing off types of elements
    gui = {{shapeType, isBordered, color, x, y, width, height}},
    text = {{string, backgroundColor, foregroundColor, x, y}},
    button = {{string, backgroundColor, foregroundColor, x, y, functionOnClick}},
    input = {{string, backgroundColor, foregroundColor, x, y, functionOnReturn}},
    animation = string (slideup, slidedown, etc, fadein, fadeout),
    fixed = bool (true if it can't be moved, like the main menu),
    main = function
      -- Basically ran every time the interface is updated. Will be given
      -- eventData in order for more flexibility. 
  })
--]]

local function shortenString(string, n)
  if type(string) ~= "string" then return end
  if string.len(string) <= n then return string end
  
  local nString = ""
  for i = 1, n - 2 do nString = nString .. string.char(string:byte(i)) end
  return nString.. ".."
end

local function splitString(str, sep)
  local sep, result = sep or "%s", {}
  for output in string.gmatch(str, "([^"..sep.."]+)") do result[#result + 1] = output end
  return result
end

-- The following shape-drawing functions are used from the
-- ComputerCraft Graphics Library, Written by Bobby Lucero.
-- Credits to him for this awesome library.

local function fillBottomFlatTriangle(v1x, v1y, v2x, v2y, v3x, v3y, color)   
    local invslope1 = (v2x - v1x) / (v2y - v1y)
    local invslope2 = (v3x - v1x) / (v3y - v1y)
    local curx1, curx2 = v1x, v1x

    for scanlineY = v1y, v2y do
        paintutils.drawLine(curx1, scanlineY, curx2, scanlineY, color)
        curx1 = curx1 + invslope1
        curx2 = curx2 + invslope2
    end
end

local function fillTopFlatTriangle(v1x, v1y, v2x, v2y, v3x, v3y, color)
    local invslope1 = (v3x - v1x) / (v3y - v1y)
    local invslope2 = (v3x - v2x) / (v3y - v2y)
    local curx1, curx2 = v3x, v3x

    for scanlineY = v3y - 1, v1y + 1, -1 do
        curx1 = curx1 - invslope1
        curx2 = curx2 - invslope2
        paintutils.drawLine(math.floor(curx1), scanlineY, math.floor(curx2), scanlineY, color)
    end
end

local function Write(x, y, string) Screen.setCursorPos(x, y); Screen.write(string) end

local function drawBorder(x, y, width, height, bc, tc)
  Screen.setBackgroundColor(bc); Screen.setTextColor(tc)
  Write(x, y, "+"); Write((x - 1) + width, y, "+")
  Write(x, (y - 1) + height, "+"); Write((x - 1) + width, (y - 1) + height, "+")
  Write(x + 1, y, string.rep("-", width - 2)); Write(x + 1, y + height - 1, string.rep("-", width - 2))
  for i = 1, height - 2 do Write(x, y + i, "|"); Write((x - 1) + width, y + i, "|") end
end

shapeType["pixel"] = function(x1, y1, color)
  paintutils.drawPixel(x1 + offsetX, y1 + offsetY, color)
end

shapeType["rectangle"] = function(x1, y1, w, h, color, border)
  local x1, y1 = x1 + offsetX, y1 + offsetY
  for i = 1, h do paintutils.drawLine(x1, y1 - 1 + i, x1 + w - 1, y1 - 1 + i, color) end
  if border then drawBorder(x1, y1, w, h, border[1], border[2]) end
end

shapeType["rectangle:line"] = function(x1, y1, w, h, color, border)
  local x1, y1, w, h = x1 + offsetX, y1 + offsetY, w + offsetX, h + offsetY
  paintutils.drawLine(x1, y1, x1 + w - 1, y1, color)
  paintutils.drawLine(x1, y1 + h - 1, x1 + w - 1, y1 + h - 1, color)
  paintutils.drawLine(x1, y1, x1, y1 + h - 1, color)
  paintutils.drawLine(x1 + w - 1, y1, x1 + w - 1, y1 + h - 1, color)
  if border then drawBorder(x1, y1, w, h, border[1], border[2]) end
end

shapeType["circle"] = function(xm, ym, r, color)
    shapeType["fillEllipse"](xm + offsetX, ym + offsetY, r, r, color)
end

shapeType["circle:line"] = function(xm, ym, r, color)
  local xm, ym = xm + offsetY, ym + offsetY
  local x, y, err = -r, 0, 2 - 2 * r
  while x < 0 do
      paintutils.drawPixel(xm - x, ym + y, color)
      paintutils.drawPixel(xm - y, ym - x, color)
      paintutils.drawPixel(xm + x, ym - y, color)
      paintutils.drawPixel(xm + y, ym + x, color)
      local r = err
       
      if r <= y then 
          y = y + 1
          err = err + y * 2 + 1 
      end
      
      if r > x or err > y then 
          x = x + 1
          err = err + x * 2 + 1 
      end
  end
end

shapeType["ellipse"] = function(originX, originY, w, h, color)
  local originX, originY, w, h = x1 + offsetX, y1 + offsetY, w + offsetX, h + offsetY
  local hh, ww = h * h, w * w
  local hhww = hh*ww
  local x0, dx = w, 0

  for x = -w, w do
    paintutils.drawPixel(originX + x, originY, color)
  end  

  for y = 1, h do
    local x1 = x0 - (dx - 1)
    for i = x1, 0, -1 do

      if (x1 * x1 * hh + y * y * ww <= hhww) then
        break
      end
      x1 = x1 - 1
    end

    dx = x0 - x1
    x0 = x1

    for x = -x0, x0 do
      paintutils.drawPixel(originX + x, originY - y, color)
      paintutils.drawPixel(originX + x, originY + y, color)
    end
  end
end

shapeType["ellipse:line"] = function(xc, yc, rx, ry, color)
  local xc, yc = xc + offsetY, yc + offsetY
  local rxSq, rySq = rx * rx, ry * ry
  local x, y = 0, ry
  local px, py = 0, 2 * rxSq * y
  
  paintutils.drawPixel(xc + x, yc + y, color) 
  paintutils.drawPixel(xc - x, yc + y, color)
  paintutils.drawPixel(xc + x, yc - y, color)
  paintutils.drawPixel(xc - x, yc - y, color)
  
  local p = rySq - (rxSq * ry) + (0.25 * rxSq)
  while (px < py) do
      x = x + 1
      px = px + 2 * rySq
      if (p < 0) then
          p = p + rySq + px
      else
          y = y - 1
          py = py - 2 * rxSq;
          p = p + rySq + px - py;
      end
      paintutils.drawPixel(xc + x, yc + y, color)
      paintutils.drawPixel(xc - x, yc + y, color)
      paintutils.drawPixel(xc + x, yc - y, color)
      paintutils.drawPixel(xc - x, yc - y, color)
  end
  
  p = rySq * (x + 0.5) * (x + 0.5) + rxSq * (y - 1) * (y - 1) - rxSq * rySq
  
  while (y > 0) do
      y = y - 1
      py = py - 2 * rxSq
      if (p > 0) then
          p = p + rxSq - py
      else
          x = x + 1
          px = px + 2 * rySq
          p = p + rxSq - py + px
      end
      
      paintutils.drawPixel(xc + x, yc + y, color)
      paintutils.drawPixel(xc - x, yc + y, color)
      paintutils.drawPixel(xc + x, yc - y, color)
      paintutils.drawPixel(xc - x, yc - y, color)
  end
end

shapeType["arc"] = function(x, y, radius, angle1, angle2, p, color)
  local x, y = x + offsetY, y + offsetY
  local points = p or math.abs(((angle2 - angle1) / 20))
  
  if points <= 0 or angle1 == angle2 then
      return
  end

  local angle_shift = (angle2 - angle1) / points

  if angle_shift == 0 then 
      return 
  end

  local phi = math.rad(angle1)
  local num_coords = points + 2
  
  local coords = {}    -- new array
  for i=1, num_coords do
      point = {}
      point.x = 0
      point.y = 0
      table.insert(coords,point)
  end
  coords[1].x = x
  coords[1].y = y

  for i = 2, #coords do
      coords[i].x = (radius * math.cos(phi)) + x 
      coords[i].y = (radius * math.sin(phi)) + y
      phi = phi + math.rad(angle_shift)
  end

  local tris = {}
  for i = 1, #coords do
      if i == #coords then
          tri.ax = math.floor(coords[i].x)
          tri.ay = math.floor(coords[i].y)
          tri.bx = math.floor(coords[i-1].x)
          tri.by = math.floor(coords[i-1].y)
          tri.cx = math.floor(coords[1].x)
          tri.cy = math.floor(coords[1].y)
      else
          tri = {}
          tri.ax = math.floor(coords[i].x)
          tri.ay = math.floor(coords[i].y)
          tri.bx = math.floor(coords[i+1].x)
          tri.by = math.floor(coords[i+1].y)
          tri.cx = math.floor(coords[1].x)
          tri.cy = math.floor(coords[1].y)
          table.insert(tris,tri)
      end
  end

  for i = 1, #tris do
      fillTriangle(tris[i].ax, tris[i].ay, tris[i].bx, tris[i].by, tris[i].cx, tris[i].cy, color)
  end
  coords = nil
end

shapeType["arc:line"] = function(x, y, radius, angle1, angle2, color)
  local x, y = x + offsetY, y + offsetY
  local points = math.abs(angle2 - angle1) / 2
  
  if angle1 == angle2 then
      return
  end

  local angle_shift = (angle2 - angle1) / points

  if angle_shift == 0 then 
      return 
  end

  local phi = math.rad(angle1)
  local num_coords = points + 2
  
  local coords = {}    -- new array
  for i=1, num_coords do
      point = {}
      point.x = 0
      point.y = 0
      table.insert(coords,point)
  end
  coords[1].x = x
  coords[1].y = y
  coords[#coords].x = x
  coords[#coords].y = y

  for i = 2, #coords - 1 do
      coords[i].x = (radius * math.cos(phi)) + x 
      coords[i].y = (radius * math.sin(phi)) + y
      phi = phi + math.rad(angle_shift)
  end

  for i = 1, #coords do
      if i == #coords then
          paintutils.drawPixel(coords[i].x, coords[i].y, color)
      else
          paintutils.drawLine(coords[i].x, coords[i].y, coords[i+1].x, coords[i+1].y, color)
      end
  end
  coords = nil
end

shapeType["traingle"] = function(v1x, v1y, v2x, v2y, v3x, v3y, color)
  local vt1 = {}
  vt1.x = v1x
  vt1.y = v1y
  
  local vt2 = {}
  vt2.x = v2x
  vt2.y = v2y
  
  local vt3 = {}
  vt3.x = v3x
  vt3.y = v3y
  
  if (vt1.y > vt2.y) then
      vTmp = vt1
      vt1 = vt2
      vt2 = vTmp
  end

  if (vt1.y > vt3.y) then
      vTmp = vt1
      vt1 = vt3
      vt3 = vTmp
  end

  if (vt2.y > vt3.y) then
      vTmp = vt2
      vt2 = vt3
      vt3 = vTmp
  end

  if (vt2.y == vt3.y) then
      fillBottomFlatTriangle(vt1.x, vt1.y, vt2.x, vt2.y, vt3.x, vt3.y, color)
  elseif (vt1.y == vt2.y) then
      fillTopFlatTriangle(vt1.x, vt1.y, vt2.x, vt2.y, vt3.x, vt3.y, color)
  else
      local vt4 =  {}
      vt4.x = vt1.x + ((vt2.y - vt1.y) / (vt3.y - vt1.y)) * (vt3.x - vt1.x)
      vt4.y = vt2.y
      fillBottomFlatTriangle(vt1.x, vt1.y, vt2.x, vt2.y, vt4.x, vt4.y, color)
      fillTopFlatTriangle(vt2.x, vt2.y, vt4.x, vt4.y, vt3.x, vt3.y, color)
  end
end

shapeType["traingle:line"] = function(v1x, v1y, v2x, v2y, v3x, v3y, color)
    paintutils.drawLine(v1x, v1y, v2x, v2y, color)
    paintutils.drawLine(v2x, v2y, v3x, v3y, color)
    paintutils.drawLine(v3x, v3y, v1x, v1y, color)
end

_G.Interface = {}

function Interface.newInterface(interfaceName, interfaceElements)
  if type(interfaceName) ~= "string" then return end
  if type(interfaceElements) ~= "table" then return end
  interfaces[interfaceName] = interfaceElements
end

function Interface.getInterfaceData(interfaceName)
  if type(interfaceName) ~= "string" then return end
  if interfaces[interfaceName] then return interfaces[interfaceName] end
end

local function drawLabel(x, y, bc, tc, str)
  Screen.setCursorPos(x, y); Screen.setBackgroundColor(bc)
  Screen.setTextColor(tc); Screen.write(str)
end

function Interface.updateInterface(interfaceName, eventData, playerName)
  if type(interfaceName) ~= "string" then return end
  if not interfaces[interfaceName] then return end
  local interface = interfaces[interfaceName]
  local eventData = eventData or {} 

  --if offsetX < 0 then offsetX = offsetX + 1 end
  --if interface.animation then
  --  if justOpened then
  --    if interface.animation == "slideright"
  --    justOpened = false
  --  end
  --end

  if interface.main then 
    if interface.main(eventData) then currentSelected, currentList = 1, 1; justOpened = true; return true end
  end
  
  if interface.gui then
    for k, v in pairs(interface.gui) do
      local element = interface.gui[k]
      if not shapeType[(element.shape or element[1])] or not (element.parameters or element[2]) then return end
      shapeType[element.shape or element[1]](unpack(element.parameters or element[2]))
    end
  end

  if interface.list then
    for k, v in pairs(interface.list) do
      local element = interface.list[k]
      if not (element.table or element[1]) or not (element.x or element[2]) or not (element.y or element[3]) or not (element.width or element[4]) or not (element.height or element[5]) then return end
      local currentEntry, maxEntries, value, bg, fg = 1, 20

      for y = 1, (element.height or element[5]) do
        for x = 1, (element.width or element[4]) do
          --if k == currentList then value, texture, maxEntries = (element.table or element[1])(playerName, currentEntry, currentSelected, x, y) else value, texture = (element.table or element[1])(playerName, currentEntry, -1, x, y) end
          value, bg, fg = (element.table or element[1])(playerName, currentEntry, currentSelected, x, y)
          if type(value) == "string" then drawLabel((element.x or element[2]) + x - 1 + offsetX, (element.y or element[3]) + y - 1, bg, fg, value) 
          elseif type(value) == "number" then if Assets[value] then drawLabel((element.x or element[2]) + x - 1 + offsetX, (element.y or element[3]) + y - 1, Assets[value].texture[1] or colors.blue, Assets[value].texture[2] or colors.white, Assets[value].texture[3] or " ") end end
        end; currentEntry = currentEntry + 1
      end

      if tostring(eventData[1]) == "key" then
        if eventData[2] == 17 or eventData[2] == 200 then currentSelected = currentSelected - 1 end -- Up key
        if eventData[2] == 31 or eventData[2] == 208 then currentSelected = currentSelected + 1 end -- Down key
        if eventData[2] == 30 or eventData[2] == 203 then currentList = currentList - 1 end -- left key
        if eventData[2] == 32 or eventData[2] == 205 then currentList = currentList + 1 end -- Right key
        if currentSelected < 1 then currentSelected = maxEntries end; if currentSelected > maxEntries then currentSelected = 1 end
        if currentList < 1 then currentList = #interface.list end; if currentList > #interface.list then currentList = 1 end
        if eventData[2] == keys.enter then
          local exitFunction = (element.exit or element[6]) or function() end; exitFunction(playerName, currentSelected)
        end
      elseif eventData[1] == "mouse_scroll" then
        currentSelected = currentSelected + eventData[2]
        if currentSelected < 1 then currentSelected = maxEntries end; if currentSelected > maxEntries then currentSelected = 1 end
      end
    end
  end

  if interface.text then
    for k, v in pairs(interface.text) do
      local element = interface.text[k]
      if not (element.text or element[1]) or not (element.x or element[2]) or not (element.y or element[3]) or not (element.bcolor or element[4]) or not (element.tcolor or element[5]) then return end
      drawLabel((element.x or element[2]) + offsetX, element.y or element[3], element.bcolor or element[4], element.tcolor or element[5], element.text or element[1])
    end
  end

  if interface.button then
    for k, v in pairs(interface.button) do
      local element = interface.button[k]
      if not (element.text or element[1]) or not (element.x or element[2]) or not (element.y or element[3]) or not (element.bcolor or element[4]) or not (element.tcolor or element[5]) or not (element.func or element[6]) then return end
      drawLabel((element.x or element[2]) + offsetX, element.y or element[3], element.bcolor or element[4], element.tcolor or element[5], element.text or element[1])
      if eventData[1] == "mouse_click" then
        if eventData[2] == 1 and eventData[3] >= (element.x or element[2]) and eventData[3] <= #(element.text or element[1]) + (element.x or element[2]) - 1 and eventData[4] == (element.y or element[3]) then
          (element.func or element[6])()
        end
      end
    end
  end

  if interface.input then
    for k, v in pairs(interface.input) do
      local element = interface.input[k]
      --if not interfaces.input[k].currentInput then interfaces.input[k].currentInput = "" end
      if not (element.text or element[1]) or not (element.x or element[2]) or not (element.y or element[3]) or not (element.bcolor or element[4]) or not (element.tcolor or element[5]) or not (element.func or element[6]) then return end
      drawLabel((element.x or element[2]) + offsetX, element.y or element[3], element.bcolor or element[4], element.tcolor or element[5], element.text or element[1])
      if eventData[1] == "mouse_click" then
        if eventData[2] == 1 and eventData[3] >= (element.x or element[2]) and eventData[3] <= #(element.text or element[1]) + (element.x or element[2]) - 1 and eventData[4] == (element.y or element[3]) then
          
        end
      end
    end
  end

  if eventData[1] == "key" then
    if interface.escapeKeys then
      for key, value in pairs(interface.escapeKeys) do if eventData[2] == value then currentSelected = 1; justOpened = true; return true end end
    elseif eventData[2] == keys.e then currentSelected, currentList = 1, 1; justOpened = true; return true end
  end
end

function Interface.modifyInterface(interfaceName, parameters)

end

-- Make the menus drag-able; That would be awesome. Have an option to have it stuck or not.

local function openInventory(playerName, entry, selected, x, y)
  local playerInventory = Player.getInventory(playerName)
  if not playerInventory[entry] then return end
  if x == 1 then 
    if entry == selected then return "[" ..shortenString(Assets[playerInventory[entry].ID].name, 9).. "]", {colors.blue, colors.white} 
    else return shortenString(Assets[playerInventory[entry].ID].name, 9), colors.blue, colors.lightGray, #playerInventory end
  elseif x == 13 then return playerInventory[entry].ID
  elseif x == 14 then return "x" ..playerInventory[entry].Amount, colors.blue, colors.lightGray, #playerInventory
  end --else return _, _, #playerInventory end
end

local function openChest(playerName, entry, selected, x, y)
  local playerInventory = Player.getInventory(playerName)
  local interactionCoordsX, interactionCoordsY = Player.getFacingCoords(playerName)
  local Chest = Level.getData(Player.getDimension(playerName), interactionCoordsX, interactionCoordsY).Block or false
  if not Chest or not Assets[Chest.ID].inventory then return end; Chest.storage = Chest.storage or {}; if not Chest.storage[entry] then return end
  if x == 1 then 
    if entry == selected then return "[" ..shortenString(Assets[Chest.storage[entry].ID].name, 9).. "]", {colors.blue, colors.white} 
    else return shortenString(Assets[Chest.storage[entry].ID].name, 9), colors.blue, colors.lightGray, #Chest.storage end
  elseif x == 13 then return playerInventory[entry].ID
  elseif x == 14 then return "x" ..Chest.storage[entry].Amount, colors.blue, colors.lightGray, #Chest.storage
  end --else return _, _, #Chest.storage end
end

local function equipItem(playerName, selected)
  local playerInventory = Player.getInventory(playerName)
  local interactionCoordsX, interactionCoordsY = Player.getFacingCoords(playerName)
  local Chest = Level.getData(Player.getDimension(playerName), interactionCoordsX, interactionCoordsY).Block or false
  if not Chest or not Chest.ID or not Assets[Chest.ID].inventory then  
    local playerInventory = Player.getInventory(playerName)
    if not playerInventory[selected] then return end
    Player.equipItem(playerName, selected)
  else
    Chest.storage = Chest.storage or {}
    if #Chest.storage >= Assets[Chest.ID].inventory then return end
    Chest.storage[#Chest.storage + 1] = playerInventory[selected]
    table.remove(playerInventory, selected)
    Player.setInventory(playerName, playerInventory)
  end
end

local function switchItem(playerName, selected)
  local playerInventory = Player.getInventory(playerName)
  local interactionCoordsX, interactionCoordsY = Player.getFacingCoords(playerName)
  local Chest = Level.getData(Player.getDimension(playerName), interactionCoordsX, interactionCoordsY).Block or false
  if not Chest or not Assets[Chest.ID].inventory then return end; Chest.storage = Chest.storage or {}; if not Chest.storage[selected] then return end
  playerInventory[#playerInventory + 1] = Chest.storage[selected]
  table.remove(Chest.storage, selected)
  Player.setInventory(playerName, playerInventory)
end

Interface.newInterface("Inventory", { -- What the inventory interface could look like
  gui = {{"rectangle", {2, 4, 18, 14, colors.blue, {colors.blue, colors.white}}}},
  text = {{"INVENTORY", 3, 4, colors.blue, colors.yellow}},
  list = {{openInventory, 3, 5, 16, 12, equipItem}}
})

Interface.newInterface("Chest", { -- What the chest interface could look like
  gui = {{"rectangle", {2, 4, 18, 14, colors.blue, {colors.blue, colors.white}}}, {"rectangle", {22, 4, 18, 14, colors.blue, {colors.blue, colors.white}}}},
  text = {{"INVENTORY", 4, 4, colors.blue, colors.yellow}, {"CHEST", 24, 4, colors.blue, colors.yellow}},
  list = {{openInventory, 3, 5, 16, 12, equipItem}, {openChest, 23, 5, 16, 12, switchItem}}
})

_G.Menu = {}

function Menu.Write(x, y, string) Screen.setCursorPos(x, y); Screen.write(string) end
function Menu.drawMenuBox(x, y, width, height, title, backgroundColor, borderColor, titleColor)
  local backgroundColor = backgroundColor or colors.blue
  local borderColor = borderColor or colors.white
  local titleColor = titleColor or colors.yellow

  for i = 1, height - 2 do paintutils.drawLine(x + 1, y + i, x + width - 2, y + i, backgroundColor) end

  Screen.setTextColor(borderColor)
  Menu.Write(x, y, "+"); Menu.Write((x - 1) + width, y, "+")
  Menu.Write(x, (y - 1) + height, "+"); Menu.Write((x - 1) + width, (y - 1) + height, "+")

  for i = 1, height - 2 do Menu.Write(x, y + i, "|"); Menu.Write((x - 1) + width, y + i, "|") end
  for i = 1, width - 2 do Menu.Write(x + i, y, "-"); Menu.Write(x + i, (y - 1) + height, "-") end
  if title then Screen.setTextColor(titleColor); Menu.Write(x + 2, y, title) end
end

local function menuList(x, y, width, height, title, table, selection)
  Menu.drawMenuBox(x, y, width, height, title)

  local returnValue = false
  for i = 1 + (selection - 1), height - 2  + (selection - 1) do
    if table[i] then
      Screen.setBackgroundColor(colors.blue)
      Screen.setTextColor(colors.lightGray)
      Screen.setCursorPos(x + 2, y + (i - selection + 1))

      if i == selection then print("[" ..shortenString(Assets[table[i].ID].name, 7).. "]"); returnValue = i
      else print(shortenString(Assets[table[i].ID].name, 7)) end
      
      Menu.Write(x + 11, y + (i - selection + 1), "x" ..table[i].Amount)
      Screen.setCursorPos(x + 15, y + (i - selection + 1))
      if Assets[table[i].ID].type == "block" or Assets[table[i].ID].type == "blocktile" or Assets[table[i].ID].type == "tile" or Assets[table[i].ID].type == "liquid" then
        Screen.setBackgroundColor(Assets[table[i].ID].texture[1] or colors.blue)
        Screen.setTextColor(Assets[table[i].ID].texture[2] or colors.white)
        Screen.write(Assets[table[i].ID].texture[3] or "?")
      else
        Screen.setTextColor(Assets[table[i].ID].texture[1])
        Screen.write(Assets[table[i].ID].texture[2])
      end
    else break end
  end

  return returnValue
end

local function translateKey(key, value, maxValue, manual)
  if not manual then
    if key == 17 or key == 200 then value = value - 1 end -- Up Key
    if key == 31 or key == 208 then value = value + 1 end -- Down Key
  else value = value + manual end
  if maxValue and value < 1 then value = maxValue end
  if maxValue and value > maxValue then value = 1 end
  return value
end

local nString, history = "",  {}
local function newRead(eventData, x, y, maxWidth)
  if not eventData then return end
  local maxWidth = maxWidth or 100
  Screen.setCursorBlink(true)

  if eventData[1] == "char" then if #nString < maxWidth then nString = nString.. eventData[2]; end 
  elseif eventData[1] == "key" then
    if eventData[2] == 14 then nString = string.sub(nString, 1, #nString - 1);  
    elseif eventData[2] == 28 then Screen.setCursorBlink(false); return nString end
  end

  Screen.setBackgroundColor(colors.gray)
  Screen.setTextColor(colors.white)
  Screen.setCursorPos(x, y)
  Screen.write(nString)
  Screen.drawScreen()
end

function Menu.newInterface(interfaceName, newInterface)
  if type(interfaceName) ~= "string" or type(newInterface) ~= "function" then return end; menuInterfaces[interfaceName] = newInterface
end

function Menu.getInterface(interfaceName)
  if type(interfaceName) ~= "string" then return end; return menuInterfaces[interfaceName] or false
end

local function openCraftingInterface(eventData, currentPlayer)
  local interactionCoords = {Player.getFacingCoords(currentPlayer)}
  local Block = Level.getData(Player.getDimension(currentPlayer), interactionCoords[1], interactionCoords[2]).Block
  local craftingTables = Crafting.getCraftingTables()
  local tableID = Crafting.isCraftingTable(Block.ID)
  local x, y, width, height = craftingTables[tableID].Size[1], craftingTables[tableID].Size[2], craftingTables[tableID].Size[3], craftingTables[tableID].Size[4]

  if pocket then width = width - 6 end
  Menu.drawMenuBox(x, y, width, height, craftingTables[tableID].Name)
  Menu.drawMenuBox(width + 3, y, width, (height / 2) - 4, "HAVE")
  Menu.drawMenuBox(width + 3, (y + height / 2) - 3, width, (height / 2) + 3, "REQUIRED")

  if eventData[1] == "key" then 
    selected = translateKey(eventData[2], selected, #craftingTables[tableID].Recipes)
    if eventData[2] == 16 or eventData[2] == 18 then selected = 1; return true -- Q, E
    elseif eventData[2] == 28 then -- Enter 
      if Player.getMode(currentPlayer) == 0 then
        for i = 1, #craftingTables[tableID].Recipes[selected].Input / 2 do
          local _, amountHave = Player.checkInventory(currentPlayer, craftingTables[tableID].Recipes[selected].Input[(i * 2) - 1]) 
          if not amountHave or amountHave < craftingTables[tableID].Recipes[selected].Input[i * 2] then return end
        end

        for i = 1, #craftingTables[tableID].Recipes[selected].Input / 2 do
          local giveID = craftingTables[tableID].Recipes[selected].Input[(i * 2) - 1]
          local giveAmount = craftingTables[tableID].Recipes[selected].Input[i * 2]
          if giveID and giveAmount then Player.removeItem(currentPlayer, giveID, giveAmount) end
        end
        Player.giveItem(currentPlayer, craftingTables[tableID].Recipes[selected].Output[1], craftingTables[tableID].Recipes[selected].Output[2])
      else Player.giveItem(currentPlayer, craftingTables[tableID].Recipes[selected].Output[1], craftingTables[tableID].Recipes[selected].Output[2]) end
    end
  end

  Screen.setTextColor(colors.lightGray)
  for i = 1 + (selected - 1), height - 2 + (selected - 1) do
    Screen.setCursorPos(x + 1, y + (i - selected) + 1)
    if craftingTables[tableID].Recipes[i] then 
      local assetName = Level.convertID(craftingTables[tableID].Recipes[i].Output[1])
      if type(assetName) ~= "string" then return end
      if i == selected then Screen.write("[" ..shortenString(assetName, width - 4).. "]") else Screen.write(shortenString(assetName, width - 4)) end
    end
  end

  if not craftingTables[tableID].Recipes[selected].Input then return end
  for i = 1, #craftingTables[tableID].Recipes[selected].Input / 2 do
    local slot, amountHave = Player.checkInventory(currentPlayer, craftingTables[tableID].Recipes[selected].Input[(i * 2) - 1])
    if (Player.getMode(currentPlayer) == 0 and amountHave and amountHave >= craftingTables[tableID].Recipes[selected].Input[i * 2]) or Player.getMode(currentPlayer) == 1 then Screen.setTextColor(colors.lightGray) else Screen.setTextColor(colors.gray) end
    Menu.Write(width * 2 - 1, y + 4 + i, "x" ..craftingTables[tableID].Recipes[selected].Input[i * 2])
    Menu.Write(width + 4, y + 4 + i, shortenString(Level.convertID(craftingTables[tableID].Recipes[selected].Input[(i * 2) - 1]) or "Unknown", width - 4))
  end

  local _, amountHave = Player.checkInventory(currentPlayer, craftingTables[tableID].Recipes[selected].Output[1]); amountHave = amountHave or 0
  if amountHave ~= 0 then Screen.setTextColor(colors.lightGray) else Screen.setTextColor(colors.gray) end
  Screen.setCursorPos(width + 4, y + 1)
  Screen.write(shortenString(Level.convertID(craftingTables[tableID].Recipes[selected].Output[1]), width - 6))
  Screen.setCursorPos(width * 2 - 1, y + 1)
  Screen.write("x" ..amountHave)
end

local sizeOptions = {
  {"SMALL: 64x64", 64},
  {"MEDIUM: 96x96", 96},
  {"LARGE: 128x128", 128}
}

local levelSelection, sizeSelection = 1, 1
local createNewWorld = false
local worldName = "World"
local shouldRead = false

local function levelMenu(eventData)
  local fileList = fs.list(mainFolder.. "/Saves")

  if eventData[1] == "key" and not shouldRead then
    if createNewWorld then sizeSelection = translateKey(eventData[2], sizeSelection, 3)
    else levelSelection = translateKey(eventData[2], levelSelection, #fileList)
    if eventData[2] == 28 and fileList[levelSelection] then File.loadWorld(fileList[levelSelection]); return "singlePlayer" end end

  elseif eventData[1] == "mouse_scroll" and not shouldRead then 
    if createNewWorld then sizeSelection = translateKey(_, sizeSelection, 3, eventData[2])
    else levelSelection = translateKey(_, levelSelection, #fileList, eventData[2]) end

  elseif eventData[1] == "mouse_click" and not shouldRead then
    if eventData[3] >= ((ScreenWidth - 12) / 2) and eventData[3] <= ((ScreenWidth - 12) / 2) + 3 and eventData[4] == ScreenHeight - 4 and not createNewWorld then createNewWorld = true; levelSelection = 1 end
    if eventData[3] >= ((ScreenWidth - 12) / 2) - 1 and eventData[3] <= ((ScreenWidth - 12) / 2) + 3 and eventData[4] == 13 and createNewWorld then createNewWorld = false; sizeSelection = 1; worldName = "World" end
    if eventData[3] >= ((ScreenWidth - 14) / 2) - 1 and eventData[3] <= ((ScreenWidth - 14) / 2) + 15 and eventData[4] == 12 and createNewWorld then 
      paintutils.drawLine(((ScreenWidth - 12) / 2) - 1, 12, ((ScreenWidth - 12) / 2) + 14, 12, colors.gray)
      Screen.setTextColor(colors.white); Screen.setCursorPos(((ScreenWidth - 14) / 2), 12); shouldRead = true 
    end
    if eventData[3] >= ((ScreenWidth - 12) / 2) + 5 and eventData[3] <= ((ScreenWidth - 12) / 2) + 12 and eventData[4] == 13 and createNewWorld then
      Level.setWorld(Level.newWorld(sizeOptions[sizeSelection][2], sizeOptions[sizeSelection][2]))
      local currentPlayer = Player.getCurrentPlayer()
      Player.newPlayer(currentPlayer)
      Player.giveItem(currentPlayer, 150, 1) -- Punch Item
      Player.giveItem(currentPlayer, 13, 1) -- Crafting Table
      Player.giveItem(currentPlayer, 210, 3) -- Apple
      while true do
        local rx, ry = math.random(sizeOptions[sizeSelection][2]), math.random(sizeOptions[sizeSelection][2])
        local Data = Level.getData(0, rx, ry)
        if Data.Block and Assets[Data.Tile.ID].type ~= "liquid" then Player.setCoordinates(currentPlayer, rx, ry); Level.setSpawnPoint({rx, ry}); break end
      end
      File.saveWorld(worldName); createNewWorld = false; worldName = "World"
    end
  end

  local offset = 0; if pocket then offset = 1 end
  if createNewWorld then
    Screen.setBackgroundColor(colors.black)
    Screen.setTextColor(colors.white); Menu.Write(((ScreenWidth - 12) / 2) - 1, 7, "WORLD GENERATION"); Screen.setTextColor(colors.lightGray)
    for y = 1, #sizeOptions do 
      if y == sizeSelection then Menu.Write(((ScreenWidth - 12) / 2) - 1 + offset, 7 + y, "[" ..sizeOptions[y][1].. "]")
      else Menu.Write(((ScreenWidth - 12) / 2) + offset, 7 + y, sizeOptions[y][1]) end
    end
    Screen.setTextColor(colors.lightBlue); Menu.Write(((ScreenWidth - 12) / 2), 13, "BACK"); Menu.Write(((ScreenWidth - 12) / 2) + 6, 13, "GENERATE");
    paintutils.drawLine(((ScreenWidth - 12) / 2) - 1, 12, ((ScreenWidth - 12) / 2) + 14, 12, colors.gray)
    if not shouldRead then
      Screen.setTextColor(colors.white); Menu.Write(((ScreenWidth - 14) / 2), 12, worldName)
    else
      local name = newRead(eventData, ((ScreenWidth - 12) / 2) - 1, 12, 16)
      if name then worldName = name; shouldRead = false end
    end
  else
    Screen.setTextColor(colors.white)
    Menu.Write(((ScreenWidth - 12) / 2) + offset, 7, "SELECT WORLD")
    Menu.Write(((ScreenWidth - 12) / 2) + 1 + offset, ScreenHeight - 4, "NEW")
    Menu.Write(((ScreenWidth - 12) / 2) + 7 + offset, ScreenHeight - 4, "PLAY")

    for i = 1 + (levelSelection - 1), ScreenHeight - 10 + (levelSelection - 1) do
      if not fileList[i] then return end
      if levelSelection == i then Screen.setTextColor(colors.blue); Menu.Write(((ScreenWidth - 12) / 2) + offset, i + 7 - (levelSelection - 1), "[" ..fileList[i].. "]")
      else Screen.setTextColor(colors.lightGray); Menu.Write(((ScreenWidth - 12) / 2) + offset + (math.floor(#fileList[i] / 4) - 1), i + 7 - (levelSelection - 1), "[" ..fileList[i].. "]") end
    end
  end
end

local serverList = File.getServerList()
local viewingList = true
local function serverMenu(eventData) 
  local offset = 0

  if viewingList then
    Screen.setTextColor(colors.white)
    Menu.Write(((ScreenWidth - 11) / 2) + offset, 7, "SERVER LIST")
    Menu.Write(((ScreenWidth - 11) / 2) + 1 + offset, ScreenHeight - 4, "NEW")
    Menu.Write(((ScreenWidth - 11) / 2) + 7 + offset, ScreenHeight - 4, "DEL")

    local listOffset = #serverList - 7
    if listOffset < 0 then listOffset = 0 end

    for i = 1 + listOffset, 7 + listOffset do
      if serverList[i] then
        local serverName = serverList[i][1].. " - " ..serverList[i][2].. ":" ..serverList[i][3]
        Menu.Write(((ScreenWidth - 11) / 2) + offset - (#serverName / 4), 7 + i - listOffset, serverName)
      end
    end
  else

    
  end
end

local function timeoutMenu(eventData) 
end

local function modsMenu(eventData) 
end

local optionOptions = {{"NAME:"}, {"COLOR:"}}
local isReading = false

local function optionsMenu(eventData) 
  if eventData[1] == "mouse_click" and not isReading then
    if eventData[3] >= ((ScreenWidth - 12) / 2) - 4 and eventData[3] <= ((ScreenWidth - 12) / 2) + 12 and eventData[4] == 9 then
      File.setCurrentColor(2 ^ (eventData[3] - math.floor((ScreenWidth - 12) / 2) + 3))
    elseif eventData[3] >= ((ScreenWidth - 12) / 2) - 5 and eventData[3] <= ((ScreenWidth - 12) / 2) + 11 and eventData[4] == 8 then
      paintutils.drawLine(((ScreenWidth - 12) / 2) - 4, 8, ((ScreenWidth - 12) / 2) + 11, 8, colors.gray); isReading = true
    end      
  end
    
  local playerName = File.getCurrentPlayer()
  local playerColor = File.getCurrentColor()

  Screen.setBackgroundColor(colors.black)
  Screen.setTextColor(colors.lightBlue)
  Menu.Write(((ScreenWidth - 12) / 2) - 10, 8, "NAME:")
  Menu.Write(((ScreenWidth - 12) / 2) - 10, 9, "COLOR:")
  paintutils.drawLine(((ScreenWidth - 12) / 2) - 4, 8, ((ScreenWidth - 12) / 2) + 11, 8, colors.gray)
  Screen.setTextColor(colors.white)
  if not isReading then Menu.Write(((ScreenWidth - 12) / 2) - 4, 8, playerName) end
  
  for i = 1, 16 do
    Screen.setBackgroundColor(2 ^ (i - 1))
    if playerColor == 1 then Screen.setTextColor(colors.black) else Screen.setTextColor(colors.white) end
    if 2 ^ (i - 1) == playerColor then Menu.Write(((ScreenWidth - 12) / 2) - 4 + i, 9, "X")
    else Menu.Write(((ScreenWidth - 12) / 2) - 4 + i, 9, " ") end
  end

  if isReading then
    local name = newRead(eventData, ((ScreenWidth - 12) / 2) - 4, 8, 16)
    if name then File.setCurrentPlayer(name); isReading = false end
  end
end

local menuChoices = {
  {"SINGLE", 8, levelMenu},
  {"MULTI", 15, serverMenu},
  {"NEWS", 21, function() end},
  {"MODS", 26, modsMenu},
  {"OPTIONS", 31, optionsMenu},
  {"QUIT?", 39, function() end}
}

if pocket then
  menuChoices = {
    {"S", 8, levelMenu},
    {"MP", 10, serverMenu},
    {"N", 13, function() end},
    {"M", 15, modsMenu},
    {"O", 18, optionsMenu},
    {"Q", 20, function() end}
  }
end

local pauseChoices = {"RESUME", "SAVE & QUIT"}
local function pauseMenu(eventData)
  if eventData[1] == "key" then
    selected = translateKey(eventData[2], selected, #pauseChoices)
    if eventData[2] == 28 then if selected == 1 then return true else selected = 1; return "quit" end
    elseif eventData[2] == 14 then selected = 1; return true end
  end

  local offset = 0; if pocket then offset = 2 end
  Menu.drawMenuBox(math.floor(ScreenWidth / 4), math.floor(ScreenHeight / 2) - 1, math.ceil(ScreenWidth / 2) + offset, 4, "PAUSED")
  Screen.setTextColor(colors.lightGray)
  for i = 1, #pauseChoices do
    if i == selected then Menu.Write(math.floor(ScreenWidth / 4) + 1, math.floor(ScreenHeight / 2) + i - 1, "[" ..pauseChoices[i].. "]")
    else Menu.Write(math.floor(ScreenWidth / 4) + 2, math.floor(ScreenHeight / 2) + i - 1, pauseChoices[i]) end
  end
end

local function openStartInterface(eventData) 
  if eventData[1] == "mouse_click" and eventData[4] == 5 then -- Tab Selection
    for i = 1, #menuChoices do if eventData[3] >= menuChoices[i][2] and eventData[3] < menuChoices[i][2] + #menuChoices[i][1] then selected = i end end
  end

  if pocket then Menu.drawMenuBox(7, 4, ScreenWidth - 12, ScreenHeight - 6, "MC " ..File.getVersion(), colors.black, colors.blue); Screen.setCursorPos(8, 5)
  else Menu.drawMenuBox(7, 4, ScreenWidth - 12, ScreenHeight - 6, "MINIATURECRAFT " ..File.getVersion(), colors.black, colors.blue); Screen.setCursorPos(8, 5) end
  for i = 1, #menuChoices do
    Screen.setTextColor(colors.gray); if selected == i then if selected == #menuChoices then Screen.setTextColor(colors.red) else Screen.setTextColor(colors.cyan) end end
    Screen.write(menuChoices[i][1]); Screen.setTextColor(colors.blue); Screen.write("|")
  end
  Screen.setCursorPos(8, 6); Screen.write(string.rep("-", ScreenWidth - 14))

  if selected == #menuChoices then 
    local nativeTerm = term.native()
    term.redirect(nativeTerm)
    _G.error = nativeError; _G.nativeError = nil
    _G.printError = nativePrintError; _G.nativePrintError = nil
    _G.Level = {}; _G.Player = {}; _G.File = {}; _G.Crafting = {}; _G.Chat = {}; _G.Entity = {}; _G.Buffer = {}; _G.Screen = {};
    nativeTerm.setBackgroundColor(colors.black); nativeTerm.setTextColor(colors.yellow)
    nativeTerm.clear(); nativeTerm.setCursorPos(1, 1); print("Thanks for playing MiniatureCraft by Detective_Smith!")
    nativeTerm.setTextColor(colors.white)
    term.redirect(term.current())
    error()
  end
  return menuChoices[selected][3](eventData)
end

local function changeBlock(playerName, newID)
  local interactionCoordsX, interactionCoordsY = Player.getFacingCoords(playerName)
  local doorBlock = Level.getData(Player.getDimension(playerName), interactionCoordsX, interactionCoordsY).Block or false
  if not doorBlock then return end; Level.setData(Player.getDimension(playerName), interactionCoordsX, interactionCoordsY, {Block = {ID = newID}})
end

local tString, history, scroll = "",  {}, 0
local function chatInterface(eventData, playerName)
  local chatHistory = Chat.getMessages()
  local scrollOffset = (#chatHistory - 6); if scrollOffset < 0 then scrollOffset = 0 end

  Screen.setCursorBlink(true)
  if eventData[1] == "char" then if #tString < ScreenWidth then tString = tString.. eventData[2]; end 
  elseif eventData[1] == "key" then
    if eventData[2] == 14 then tString = string.sub(tString, 1, #tString - 1);  
    elseif eventData[2] == 28 then Chat.sendMessage(tString, playerName); tString = "" 
    elseif eventData[2] == 59 then tString = ""; Screen.setCursorBlink(false); return true end
  elseif eventData[1] == "mouse_scroll" then
    scroll = scroll + eventData[2]
    --if scroll - scrollOffset < #chatHistory then scroll = 0 end--; if scroll > #chatHistory + scrollOffset end
  end

  Screen.setTextColor(colors.white)
  for i = 1, 6 do paintutils.drawLine(1, ScreenHeight + i - 7, ScreenWidth / 2, ScreenHeight + i - 7, colors.lightGray) end
  for i = 1, 6 do if chatHistory[i + scroll + scrollOffset] then Menu.Write(1, ScreenHeight + i - 7, chatHistory[i + scroll + scrollOffset][1]) end end

  paintutils.drawLine(1, ScreenHeight, ScreenWidth / 2, ScreenHeight, colors.gray)
  Screen.setCursorPos(1, ScreenHeight); Screen.setTextColor(colors.yellow)
  Screen.write(">"); Screen.setTextColor(colors.white); 
  if #tString <= (ScreenWidth / 2) - 3 then Screen.write(tString) 
  else Screen.write(string.sub(tString, 1 + (#tString - ((ScreenWidth / 2) - 3)))) end
end

Menu.newInterface("Crafting", openCraftingInterface)
Menu.newInterface("Inventory", openInventoryInterface)
Menu.newInterface("Chest", openChestInterface)
Menu.newInterface("StartMenu", openStartInterface)
Menu.newInterface("dooropen", function(_, playerName) changeBlock(playerName, 34); return true end)
Menu.newInterface("doorclosed", function(_, playerName) changeBlock(playerName, 35); return true end)
Menu.newInterface("Chat", chatInterface)
Menu.newInterface("PauseMenu", pauseMenu)