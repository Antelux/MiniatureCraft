local Assets = require "Assets"
local Level = require "API/Level"
local Player = require "API/Player"
local entityData, nextID = {}, 0
local sort, ty = table.sort, type
local smt = setmetatable

local function isString(s) return ty(s) == "string"  end
local function isNumber(n) return ty(n) == "number"  end
local function isBool(b)   return ty(b) == "boolean" end
local function isTable(t)  return ty(t) == "table"   end

local EntityFunctions = {
    isTakingDamage = function(entity) return entity.invincibility > 0 end,
    isAlive        = function(entity) return entity.health > 0        end,
    getFacingCoords = function(entity)
        local entityDirection = entity.direction
        return entity.x + (entityDirection == 2 and 1) or (entityDirection == 4 and -1) or 0, entity.y + (entityDirection == 1 and -1) or (entityDirection == 3 and 1) or 0
    end,

    distanceToPlayer = function(entity, playerName)
        local player = Player.player(playerName); if not player then return end
        return entity.dim == player.dim and sqrt((entity.x - player.x) ^ 2 + (entity.y + player.y) ^ 2)
    end,

    move = function(entity, moveAmount, checkCollision)
        local entity_fx, entity_fy = entity:getFacingCoords()
        if checkCollision and Level.checkForCollision(entity.dim, entity_fx, entity_fy, {51, 61}) then return end
        entity.x, entity.y = entity_fx, entity_fy; return true
    end,

    getClosestPlayer = function(entity, radius, canSeePlayer)
        local foundPlayers = entity:getNearbyPlayers(radius)
        if #foundPlayers > 1 then sort(foundPlayers, function(a, b) return a[1] < b[1] end) end
        return foundPlayers[1] and (canSeePlayer and entity:canSeePlayer(entityid, foundPlayers[1][2]) and foundPlayers[1][2] or false) or foundPlayers[1][2]
    end,

    attack = function(entity, playerName)
        -- Make this draw the item being used in the future
        local player = Player.player(playerName); if not player then return end
        player.health = player.health - ((entity.x == player.x and entity.y == player.y and entity.damage) or 0) 
    end,

    getNearbyPlayers = function(entity, radius)
        local players = Player.names(); local foundPlayers = {}
        local edim, ex, ey = entity.dim, entity.x, entity.y
        for i = 1, #players do
            local player = Player.player(players[i]); local px, py = player.x, player.y
            foundPlayers[#foundPlayers + 1] = (edim == player.dim and px >= ex - radius and px <= ex + radius and py >= ey - radius and py <= ey + radius) and {sqrt((ex - px) ^ 2 + (ey + py) ^ 2), players[i]} 
        end
        return foundPlayers
    end,

    canSeePlayer = function()

    end
}
EntityFunctions.__index = EntityFunctions

local function newEntityInternal(entityid, overrideTable, newEntityID)
    local entity = Assets[entityid]
    entityData[newEntityID] = smt({id = entityid, x = 0, y = 0, color = colors.red, dir = math.random(4), heldItem = entity.weapon, dim = 0, health = entity.health or -1, invincibility = 0, speed = entity.speed or 5, armor = {}}, EntityFunctions)
    --ai = coroutine.create(function(i) entity.script(i) end)
    if isTable(overrideTable) then for k, v in pairs(overrideTable) do entityData[newEntityID][k] = v end end
    --coroutine.resume(entityData[newEntityID].ai, newEntityID); 
    return entityData[newEntityID]
end

return {
    new    = function(entityid, overrideTable) return newEntityInternal(entityid, overrideTable, nextID + 1) end,
    remove = function(entityid) entityData[entityid] = nil end,
    update = function() for i = 1, nextID do local entity = entityData[i]; entity = (entity and entity.health <= 0 and nil) or entity end end,
    total  = function() return nextID end,

    entity = function(entityid, newData) 
        if isTable(newData) then newEntityInternal(newData.id, newData, entityid) else return entityData[entityid] end
    end,

    entities = function(newEntities) 
        if isTable(newEntities) then 
            entityData = {}; nextID = 0
            for id, data in pairs(newEntities) do
                newEntityInternal(data.id, data, id)
            end
        else return entityData end
    end
}