local MainFolder = "" -- Remove when release
--[[
  MiniatureCraft, a game by Detective_Smith
  Current Version: 1.2

  This game is under the Creative Commons Attribution-NonCommercial 4.0 
  International Public License which basically means that you are free to:

  Share — copy and redistribute the material in any medium or format
  Adapt — remix, transform, and build upon the material

  Under the following terms:
  
  Attribution — You must give appropriate credit, provide a link to the license, 
  and indicate if changes were made. You may do so in any reasonable manner, but 
  not in any way that suggests the licensor endorses you or your use.
  
  NonCommercial — You may not use the material for commercial purposes.
  
  No additional restrictions — You may not apply legal terms or technological measures 
  that legally restrict others from doing anything the license permits.

  Enjoy and have fun! :D
--]]

if not term.isColor then
  error("Advanced Computer Required to Play.")
end

-- [Load the games API's, setting up the game's functions] --
local sx, sy = term.getSize()
local nativeTerm = term.current()
local APIFolder = MainFolder.. "/MiniAPI"
local redirect = term.redirect
local currentServer = 0
local currentChannel = 0
local modem

os.loadAPI(APIFolder.. "/FileAPI")
FileAPI.setMainDirectory(MainFolder) -- This can only be set once.
os.loadAPI(APIFolder.. "/BufferAPI")

local playerData = FileAPI.getPlayerSettings()
local useBuffer = playerData.useBuffer

if useBuffer then
  term = BufferAPI.createBuffer()
  redirect(term)
end

os.loadAPI(APIFolder.. "/LoadAPI")
local Assets = LoadAPI.loadAssets()
local loadedMods = LoadAPI.loadMods()

os.loadAPI(APIFolder.. "/LevelAPI")
os.loadAPI(APIFolder.. "/PlayerAPI")
--os.loadAPI(APIFolder.. "/EntityAPI")
os.loadAPI(APIFolder.. "/MenuAPI")
os.loadAPI(APIFolder.. "/InventoryAPI")
os.loadAPI(APIFolder.. "/CraftingAPI")
os.loadAPI(APIFolder.. "/LightingAPI")

--[[ Would use this, except some API's must be loaded first, whereas this doesnt do it
local MiniAPIs = fs.list(APIFolder)
for _, file in ipairs(MiniAPIs) do
  os.loadAPI(APIFolder.. "/" ..file)
  print("The " ..file.. " Was found, attempting to load.")
  sleep(0.05)
end
]]--

-- [Set the Directorys] -- 
local MainFolder = FileAPI.getMainDirectory()
local APIFolder = FileAPI.getAPIDirectory()
local AssetsFolder = FileAPI.getAssetsDirectory()
local ModsFolder = FileAPI.getModsDirectory()
local SavesFolder = FileAPI.getSavesDirectory()

-- [Load mods in the game] -- 
for i = 1, #loadedMods do
  if loadedMods[i].Type == "load" then
    local func = loadedMods[i].Addon
    func()
  end
end

-- [Main Variables, Shouldnt touch these] --
local sx, sy = term.getSize()
local playerX, playerY = PlayerAPI.getPlayerCoordinates()
local playerDirection = PlayerAPI.getPlayerDirection()
local OffsetX, OffsetY = LevelAPI.getOffset()
local mapSizeX, mapSizeY = -64, 64
local currentDim = PlayerAPI.getPlayerDim()
local playerHoldingItem = false
local keepDirection = false
local selectedTile = 1
local gameTick = 0.05
local gameSave = 600
local gameTime = 0
local aUpdate = 1
local currentTime = 1
local update = true
local menu = false
local debug = false
local overworld
local doLighting = playerData.doLighting 
local worldX, worldX2

--[Remake read function for buffer]--
local nativeRead = read
function drawRead( _sReplaceChar, _tHistory, _sLimit )
    term.setCursorBlink( true )

    local sLine = ""
    local nHistoryPos
    local nPos = 0
    local sLimit = _sLimit or 999999999 -- Lazy
    if _sReplaceChar then
        _sReplaceChar = string.sub( _sReplaceChar, 1, 1 )
    end
    
    local w = term.getSize()
    local sx = term.getCursorPos()
    
    local function redraw( _sCustomReplaceChar )
        local nScroll = 0
        if sx + nPos >= w then
            nScroll = (sx + nPos) - w
        end

        local cx,cy = term.getCursorPos()
        term.setCursorPos( sx, cy )
        local sReplace = _sCustomReplaceChar or _sReplaceChar
        if sReplace then
            term.write( string.rep( sReplace, math.max( string.len(sLine) - nScroll, 0 ) ) )
        else
            term.write( string.sub( sLine, nScroll + 1 ) )
        end
        term.setCursorPos( sx + nPos - nScroll, cy )
        BufferAPI.drawScreen()
    end
    
    while true do
        local sEvent, param = os.pullEvent()
        if sEvent == "char" then
            -- Typed key
            local nLine = string.sub( sLine, 1, nPos ) .. param .. string.sub( sLine, nPos + 1 )
            if #nLine <= sLimit then
              sLine = nLine
              nPos = nPos + 1
              redraw()
            end

        elseif sEvent == "paste" then
            -- Pasted text
            local nLine = string.sub( sLine, 1, nPos ) .. param .. string.sub( sLine, nPos + 1 )
            if #nLine <= sLimit then
              sLine = nLine
              nPos = nPos + string.len( param )
              redraw()
            end

        elseif sEvent == "key" then
            if param == keys.enter then
                -- Enter
                break
                
            elseif param == keys.left then
                -- Left
                if nPos > 0 then
                    nPos = nPos - 1
                    redraw()
                end
                
            elseif param == keys.right then
                -- Right                
                if nPos < string.len(sLine) then
                    redraw(" ")
                    nPos = nPos + 1
                    redraw()
                end
            
            elseif param == keys.up or param == keys.down then
                -- Up or down
                if _tHistory then
                    redraw(" ")
                    if param == keys.up then
                        -- Up
                        if nHistoryPos == nil then
                            if #_tHistory > 0 then
                                nHistoryPos = #_tHistory
                            end
                        elseif nHistoryPos > 1 then
                            nHistoryPos = nHistoryPos - 1
                        end
                    else
                        -- Down
                        if nHistoryPos == #_tHistory then
                            nHistoryPos = nil
                        elseif nHistoryPos ~= nil then
                            nHistoryPos = nHistoryPos + 1
                        end                        
                    end
                    if nHistoryPos then
                        sLine = _tHistory[nHistoryPos]
                        nPos = string.len( sLine ) 
                    else
                        sLine = ""
                        nPos = 0
                    end
                    redraw()
                end
            elseif param == keys.backspace then
                -- Backspace
                if nPos > 0 then
                    redraw(" ")
                    sLine = string.sub( sLine, 1, nPos - 1 ) .. string.sub( sLine, nPos + 1 )
                    nPos = nPos - 1                    
                    redraw()
                end
            elseif param == keys.home then
                -- Home
                redraw(" ")
                nPos = 0
                redraw()        
            elseif param == keys.delete then
                -- Delete
                if nPos < string.len(sLine) then
                    redraw(" ")
                    sLine = string.sub( sLine, 1, nPos ) .. string.sub( sLine, nPos + 2 )                
                    redraw()
                end
            elseif param == keys["end"] then
                -- End
                redraw(" ")
                nPos = string.len(sLine)
                redraw()
            end

        elseif sEvent == "term_resize" then
            -- Terminal resized
            w = term.getSize()
            redraw()

        end
    end

    local cx, cy = term.getCursorPos()
    term.setCursorBlink( false )
    term.setCursorPos( w + 1, cy )
    print()
    
    return sLine
end

if useBuffer then
  _G.read = drawRead
end

--[Interface Drawing]--
function drawPlayerStats()
  if not debug then
    for i = 1, 3 do
      paintutils.drawLine(1,i,10,i,colors.black)
    end
  
    local stats = {
      [1] = {stat = PlayerAPI.getPlayerHealth(), col = colors.red, name = "HEALTH"},
      [2] = {stat = PlayerAPI.getPlayerEnergy(), col = colors.blue, name = "ENERGY"},
      [3] = {stat = PlayerAPI.getPlayerDefence(), col = colors.green, name = "DEFENCE"}
    }

    term.setTextColor(colors.white)
    for i = 1, #stats do
      if (stats[i].stat % 2 == 0) and stats[i].stat ~= 0 then
        paintutils.drawLine(1,i,stats[i].stat / 2,i,stats[i].col)
      elseif stats[i].stat == 0 then
        term.setBackgroundColor(colors.black)
      else
        paintutils.drawLine(1,i,(stats[i].stat / 2) - 0.5,i,stats[i].col)
      end
      term.setCursorPos(1,i)
      print(stats[i].name)
    end
  end
end

function drawPlayerName(px, py, n)
  term.setBackgroundColor(colors.gray)
  term.setTextColor(colors.white)
  term.setCursorPos((px - OffsetX) - ((string.len(n) / 2) - 1),(py - OffsetY) - 3)
  print(n)
end

function drawCurrentItem(n)
  if playerInventory[n] ~= nil then
    local ID = playerInventory[n].ID
    term.setTextColor(colors.white)
    if playerInventory[n].durability ~= nil then
      for i = 1, 3 do
        paintutils.drawLine(1, (sy - 3) + i, 15,(sy - 3) + i, colors.gray)
      end
      term.setCursorPos(8 - math.floor((string.len(playerInventory[n].name) / 2)), sy - 2)
      term.write(playerInventory[n].name)
      if playerInventory[n].durability > 0 then
        paintutils.drawLine(2, sy - 1, math.ceil(13 / (Assets[ID].durability / playerInventory[n].durability) + 1), sy - 1, colors.lime)
        term.setBackgroundColor(colors.gray)
        term.setCursorPos(8 - string.len(playerInventory[n].durability),sy)
        term.write(playerInventory[n].durability.. "/" ..Assets[ID].durability)
      end
    else
      term.setBackgroundColor(colors.gray)
      term.setCursorPos(1, sy)
      term.write(" " ..playerInventory[n].name)
      term.write(" x" ..playerInventory[n].Amount.. " | ")
      term.setTextColor(playerInventory[n].Tex)
      if playerInventory[n].Tex == colors.gray then
        term.setBackgroundColor(colors.white)
      end
      term.write(playerInventory[n].Sym.. " ")
    end
  end
end

function startTimers()
  gT = os.startTimer(gameTick)
  aU = os.startTimer(aUpdate)
  gS = os.startTimer(gameSave)
end

function updateVar()
  playerX, playerY = PlayerAPI.getPlayerCoordinates()
  playerDirection = PlayerAPI.getPlayerDirection()
  OffsetX, OffsetY = LevelAPI.getOffset()
  currentDim = PlayerAPI.getPlayerDim()
end

function updateAll()

  PlayerAPI.updatePlayer(overworld,currentDim,OffsetX,OffsetY)
  if doLighting then --Laggy/Buggy but working
    LightingAPI.drawLighting(playerX - OffsetX, playerY - OffsetY, 6)
  end
  drawCurrentItem(invNum)
  drawPlayerName(playerX, playerY, PlayerAPI.getPlayerName())
  drawPlayerStats()

  for i = 1, #loadedMods do
    if loadedMods[i].Type == "loop" then
      func = loadedMods[i].Addon
      func()
    end
  end
  BufferAPI.drawScreen()
end

--[A function to send and get data from a server]--
function getMessage(...)
  if ... then
    local data 
    if type(...) ~= "table" then
      data = {...}
    else
      data = ...
    end
    data[2] = PlayerAPI.getPlayerName()

    modem.transmit(currentChannel, currentServer, textutils.serialize(data))

    local timeout = os.startTimer(10)
    local resendMessage = os.startTimer(1)

    while true do
      local event, side, send, reply, data, distance = os.pullEvent()
      if event == "modem_message" then
        return unpack(textutils.unserialize(data))
      elseif event == "timer" then
        if side == timeout then
          return "timeout"
        elseif side == resendMessage then
          modem.transmit(currentChannel, currentServer, textutils.serialize(data))
          --resendMessage = os.startTimer(1)
        end
      end
    end
  end
end

--[Gets connected peripherals, good for autofinding the modem]--
function getPeripherals()
  local p = peripheral.getNames()
  for i = 1, #p do
    if peripheral.getType(p[i]) == "modem" then
      local modemSide = peripheral.wrap(p[i])
      if modemSide.isWireless() then
        modem = modemSide
        modem.open(currentChannel)
      end
    end
  end
end

--[SinglePlayer Loop]--
function singlePlayerMode(levelname)
  LevelAPI.setWorldName(levelname)
  overworld, playerInventory, invNum = FileAPI.loadMap(levelname)
  local selectedItem = playerInventory[invNum].ID
  local worldX, worldX2 = LevelAPI.getWorldSize()
  local exitGame = false

  updateVar()
  updateAll()
  startTimers()

  while true do
    e, p1, p2, p3 = os.pullEvent()

    if e then
      --[Key events]--
      if e == "key" then 
        local aU = os.startTimer(aUpdate)
        if p1 == 17 or p1 == 200 then -- Up Key
          if not overworld[currentDim][2][playerX][playerY - 1].bgT then
            if playerY - 1 < worldX2 and playerY - 1 > worldX then
              PlayerAPI.setPlayerCoordinates(playerX, playerY - 1)
              LevelAPI.setOffset(OffsetX, OffsetY - 1)
            end
          end
          if not keepDirection then
            PlayerAPI.setPlayerDirection(1)
          end

        elseif p1 == 31 or p1 == 208 then -- Down Key
          if not overworld[currentDim][2][playerX][playerY + 1].bgT then
            if playerY + 1 < worldX2 and playerY + 1 > worldX then
              PlayerAPI.setPlayerCoordinates(playerX, playerY + 1)
              LevelAPI.setOffset(OffsetX, OffsetY + 1)
            end
          end
          if not keepDirection then
            PlayerAPI.setPlayerDirection(3)
          end

        elseif p1 == 32 or p1 == 205 then -- Right Key
          if not overworld[currentDim][2][playerX + 1][playerY].bgT then
            if playerX + 1 < worldX2 and playerX + 1 > worldX then
              PlayerAPI.setPlayerCoordinates(playerX + 1, playerY)
              LevelAPI.setOffset(OffsetX + 1, OffsetY)
            end
          end
          if not keepDirection then
            PlayerAPI.setPlayerDirection(2)
          end

        elseif p1 == 30 or p1 == 203 then -- Left Key
          if not overworld[currentDim][2][playerX - 1][playerY].bgT then
            if playerX - 1 < worldX2 and playerX - 1 > worldX then
              PlayerAPI.setPlayerCoordinates(playerX - 1, playerY)
              LevelAPI.setOffset(OffsetX - 1, OffsetY)
            end
          end
          if not keepDirection then
            PlayerAPI.setPlayerDirection(4)
          end

        elseif p1 == 59 then -- F1
          --EntityAPI.newEntity(400, playerX - 2, playerY - 2)
          --EntityAPI.newEntity(401, playerX - 1, playerY - 1)
          --EntityAPI.newEntity(450, playerX + 1, playerY + 1)
          --EntityAPI.newEntity(451, playerX + 2, playerY + 2)

        elseif p1 == 60 then -- F2
          if PlayerAPI.getPlayerMode() == 0 then
            PlayerAPI.setPlayerMode(1)
          elseif PlayerAPI.getPlayerMode() == 1 then
            PlayerAPI.setPlayerMode(0)
          end

        elseif p1 == 61 then -- F3
          debug = not debug

        elseif p1 == 62 then -- F4
          if currentDim ~= -1 then
            LevelAPI.changeDimension(-1, doLighting)
          else
            LevelAPI.changeDimension(0, doLighting)
          end

        
        elseif p1 == 63 then -- F5
          term.setCursorPos(sx - 11, sy)
          term.setBackgroundColor(colors.gray)
          term.setTextColor(colors.white)
          term.write("Saving World")
          sleep(0.05)
          FileAPI.saveMap(overworld, LevelAPI.getWorldName())
          startTimers()

        elseif p1 == 42 then -- Shift
          keepDirection = not keepDirection

        elseif p1 == 18 then -- e Aka Inventory / Interact

          InteractedBlockID, InteractedTileID = PlayerAPI.getFacingBlock(overworld,currentDim,playerX,playerY,playerDirection) 
          InteractedBlockIDName, InteractedBlockID2 = LevelAPI.checkID(InteractedBlockID)
          local modInteract, modNum, modFunc = LoadAPI.checkInteractionBlocks(InteractedBlockID2)
          update = false
          menu = true

          while true do
            e, p1, p2, p3 = os.pullEvent()
            
            if CraftingAPI.checkCraftingTables(InteractedBlockID2) then
              menu, ID = CraftingAPI.openCraftingMenu(InteractedBlockID2, playerInventory, e, p1, p2, p3)
            elseif modInteract then
              menu, ID = modFunc(e, p1, p2, p3, playerX, playerY)
            else
              menu, ID, invNum = InventoryAPI.openInventory(playerInventory, e, p1, p2, p3)
              if invNum then
                if playerInventory[invNum].ID ~= nil then
                  selectedItem = playerInventory[invNum].ID
                else
                  selectedItem = nil
                end
              end
            end

            if menu == false then
              startTimers()
              break
            end

            BufferAPI.drawScreen()
          end

        elseif p1 == 57 then -- Spacebar, use items
          local switch = PlayerAPI.useItem(overworld,currentDim,playerX,playerY,playerDirection,OffsetX,OffsetY,selectedItem,playerInventory)
          if switch then
            selectedItem = nil
          end
          BufferAPI.drawScreen()
          sleep(0.05)
          startTimers()

        elseif p1 == 14 then -- Backspace
          MenuAPI.pauseMenu(overworld, "key")
          while true do
            e, p1, p2, p3 = os.pullEvent()
            local data = MenuAPI.pauseMenu(overworld, e, p1, p2, p3)

            if data then
              if data == "ExitGame" then
                exitGame = true
                break
              elseif data == "Exit" then
                break
              end
            end
          end
        end

        if exitGame then
          break
        end

        updateVar()
        updateAll()

      --[Mouse Events]--
      elseif e == "mouse_scroll" then
      	local gm = PlayerAPI.getPlayerMode()
      	if gm == 1 then
        	selectedTile = selectedTile - p1
        end

      elseif e == "mouse_click" or e == "mouse_drag" then
      	local gm = PlayerAPI.getPlayerMode()
      	if gm == 1 then
    	    if p1 == 1 then
    	      if Assets[selectedTile] then
    	        if Assets[selectedTile].type == "tile" then
    	          overworld[currentDim][1][p2 + OffsetX][p3 + OffsetY] = Assets[selectedTile]
    	        elseif Assets[selectedTile].type == "rock" or Assets[selectedTile].type == "wood" or Assets[selectedTile].type == "any" then
    	          overworld[currentDim][2][p2 + OffsetX][p3 + OffsetY] = Assets[selectedTile]
    	        end
    	      end
    	    elseif p1 == 2 then
    	      if overworld[currentDim][2][p2 + OffsetX][p3 + OffsetY] then
    	        overworld[currentDim][2][p2 + OffsetX][p3 + OffsetY] = {}
    	      end
    	    end
        	updateAll()
    	end
      
      --[Timer events to update the world regularly]--
      elseif e == "timer" then
        if p1 == gT then
          if gameTime >= 24 then
            gameTime = 0
          else
            gameTime = gameTime + 0.001
          end
          gT = os.startTimer(gameTick)
        elseif p1 == aU then
          updateAll()
          aU = os.startTimer(aUpdate)
        end
      end

      --[Overlays]--
      
      if debug then
        for i = 1, 3 do
          paintutils.drawLine(1,i,sx,i,colors.gray)
        end
        --local entityList = EntityAPI.getEntityList()
        --local entityNumber = #entityList
        term.setTextColor(colors.white)
        term.setCursorPos(1,1)
        print("X: " ..playerX.. ", Y: " ..playerY.. ", OX: " ..OffsetX.. ", OY: " ..OffsetY) --.. " | #Entitys: " ..entityNumber)
        if Assets[selectedTile] then
          print("Selected: " ..Assets[selectedTile].name.. ", ID: " ..selectedTile)
        else
          print("Selected: None, ID: " ..selectedTile)
        end
        print("Game Time: " ..gameTime)
        term.setCursorPos(19,3) 
        print("(" ..textutils.formatTime(gameTime, true).. ")")
        term.setCursorPos(27,3)
        local gM, gMS = PlayerAPI.getPlayerMode(), "ERROR"
        if gM == 1 then
          gMS = "Creative"
        elseif gM == 0 then
          gMS = "Survival"
        end
        print("Game Mode: " ..gMS)
      end

      for i = 1, #loadedMods do
        if loadedMods[i].Type == "overlay" then
          func = loadedMods[i].Addon
          func()
        end
      end
      BufferAPI.drawScreen()
    end
  end
end

--[Multilayer Loop]--
function multiplayerMode(id, channel)
  local map, dimension, playerX, playerY, OffsetX, OffsetY, join
  local OldAssets = Assets
  currentChannel, currentServer = channel, id

  if getMessage("ping") == "pong" then 
    join = true
    Assets = getMessage("grabassets")
    if Assets == "timeout" then
      join = false
    end
  end

  map, dimension, playerX, playerY, OffsetX, OffsetY = getMessage("getstats")
  if map == "timeout" then
    join = false
  else
    term.screen = map
    BufferAPI.drawScreen()
  end

  if join then
    while true do
      e, p1, p2, p3 = os.pullEvent()
      if e then --[Key events]--
        if e == "key" then 
          if p1 == 17 or p1 == 200 then -- Up Key
            map, dimension, playerX, playerY, OffsetX, OffsetY = getMessage("moveup")

          elseif p1 == 31 or p1 == 208 then -- Down Key
            map, dimension, playerX, playerY, OffsetX, OffsetY = getMessage("movedown")

          elseif p1 == 32 or p1 == 205 then -- Right Key
            map, dimension, playerX, playerY, OffsetX, OffsetY = getMessage("moveright")

          elseif p1 == 30 or p1 == 203 then -- Left Key
            map, dimension, playerX, playerY, OffsetX, OffsetY = getMessage("moveleft")

          elseif p1 == 42 then -- Shift
            keepDirection = not keepDirection

          elseif p1 == 18 then -- e Aka Inventory / Interact
            interaction = getMessage("interact")

          elseif p1 == 57 then -- Spacebar, use items
            hit = getMessage("hit")
          end
        end
      end
    
      if map == "timeout" or keepDirection == "timeout" or interaction == "timeout" or hit == "timeout" then
        MenuAPI.multiplayerError("Server Connection Timedout.")
        break
      else
        term.screen = map
        BufferAPI.drawScreen()
      end
    end
  else
    MenuAPI.multiplayerError("Could not Establish Connection.")
  end

  Assets = OldAssets
end

--[The games main menu screen]--
function mainMenu()
  MenuAPI.mainMenu("key")
  while true do
    e, p1, p2, p3 = os.pullEvent()
    local data = MenuAPI.mainMenu(e, p1, p2, p3)

    if data then
      if data.type == "Load" then
        singlePlayerMode(data.name)    
      elseif data.type == "Multiplayer" then
        multiplayerMode(data.id, data.channel)
      elseif data.type == "Exit" then
        redirect(nativeTerm)
        break
      end
      MenuAPI.mainMenu("key")
    end
  end
end

getPeripherals()
mainMenu()