
--[[
  MiniatureCraft, a game by Detective_Smith
  Current Version: 1.1b

  This game is under the Creative Commons Attribution-NonCommercial 4.0 
  International Public License which basically means that you are free to:

  Share — copy and redistribute the material in any medium or format
  Adapt — remix, transform, and build upon the material

  Under the following terms:
  
  Attribution — You must give appropriate credit, provide a link to the license, 
  and indicate if changes were made. You may do so in any reasonable manner, but 
  not in any way that suggests the licensor endorses you or your use.
  
  NonCommercial — You may not use the material for commercial purposes.
  
  No additional restrictions — You may not apply legal terms or technological measures 
  that legally restrict others from doing anything the license permits.

  Enjoy and have fun! :D
--]]

if not term.isColor then
  error("Advanced Computer Required to Play.")
end

-- [Load the games API's, setting up the game's functions] --
local sx, sy = term.getSize()
local nativeTerm = term.current()
local APIFolder = MainFolder.. "/MiniAPI"
local redirect = term.redirect
--local MiniAPIs = fs.list(APIFolder)

os.loadAPI(APIFolder.. "/BufferAPI")
local term = BufferAPI.createBuffer()
redirect(term)

os.loadAPI(APIFolder.. "/FileAPI")
FileAPI.setMainDirectory(MainFolder) -- This can only be set once.

os.loadAPI(APIFolder.. "/LoadAPI")
local Assets = LoadAPI.loadAssets()
local loadedMods = LoadAPI.loadMods()

os.loadAPI(APIFolder.. "/LevelAPI")
os.loadAPI(APIFolder.. "/PlayerAPI")
--os.loadAPI(APIFolder.. "/EntityAPI")
os.loadAPI(APIFolder.. "/MenuAPI")
os.loadAPI(APIFolder.. "/InventoryAPI")
os.loadAPI(APIFolder.. "/CraftingAPI")
os.loadAPI(APIFolder.. "/LightingAPI")

--[[ Would use this, except some API's must be loaded first, whereas this doesnt do it
for _, file in ipairs(MiniAPIs) do
  os.loadAPI(APIFolder.. "/" ..file)
  print("The " ..file.. " Was found, attempting to load.")
  sleep(0.05)
end
]]--

-- [Set the Directorys] -- 
local MainFolder = FileAPI.getMainDirectory()
local APIFolder = FileAPI.getAPIDirectory()
local AssetsFolder = FileAPI.getAssetsDirectory()
local ModsFolder = FileAPI.getModsDirectory()
local SavesFolder = FileAPI.getSavesDirectory()

-- [Load mods in the game] -- 
for i = 1, #loadedMods do
  if loadedMods[i].Type == "load" then
    local func = loadedMods[i].Addon
    func()
  end
end

-- [Main Variables, Shouldnt touch these] --
local sx, sy = term.getSize()
local playerX, playerY = PlayerAPI.getPlayerCoordinates()
local playerDirection = PlayerAPI.getPlayerDirection()
local OffsetX, OffsetY = LevelAPI.getOffset()
local mapSizeX, mapSizeY = -64, 64
local currentDim = PlayerAPI.getPlayerDim()
local playerHoldingItem = false
local keepDirection = false
local selectedTile = 1
local gameTick = 0.05
local gameSave = 600
local gameTime = 0
local aUpdate = 1
local currentTime = 1
local update = true
local menu = false
local debug = false
local invNum = 1
local overworld
local doLighting = false -- HEAVILY RECOMMENDED THIS IS KEPT OFF! If enabled, it will cause MAJOR LAG when underground. Use at your own risk!
local worldX, worldX2

--[Sets the player's inventory, adding 3 things to it]--
local playerInventory = InventoryAPI.newInventory()
InventoryAPI.addItem(playerInventory, 150, 1)
InventoryAPI.addItem(playerInventory, 223, 1)
InventoryAPI.addItem(playerInventory, 210, 3)
local selectedItem = playerInventory[invNum].ID

--[Interface Drawing]--
function drawPlayerStats()
  if not debug then
    for i = 1, 3 do
      paintutils.drawLine(1,i,10,i,colors.black)
    end
  
    local stats = {
      [1] = {stat = PlayerAPI.getPlayerHealth(), col = colors.red, name = "HEALTH"},
      [2] = {stat = PlayerAPI.getPlayerEnergy(), col = colors.blue, name = "ENERGY"},
      [3] = {stat = PlayerAPI.getPlayerDefence(), col = colors.green, name = "DEFENCE"}
    }

    term.setTextColor(colors.white)
    for i = 1, #stats do
      if (stats[i].stat % 2 == 0) and stats[i].stat ~= 0 then
        paintutils.drawLine(1,i,stats[i].stat / 2,i,stats[i].col)
      elseif stats[i].stat == 0 then
        term.setBackgroundColor(colors.black)
      else
        paintutils.drawLine(1,i,(stats[i].stat / 2) - 0.5,i,stats[i].col)
      end
      term.setCursorPos(1,i)
      print(stats[i].name)
    end
  end
end

function drawPlayerName(px, py, n)
  term.setBackgroundColor(colors.gray)
  term.setTextColor(colors.white)
  term.setCursorPos((px - OffsetX) - ((string.len(n) / 2) - 1),(py - OffsetY) - 3)
  print(n)
end

function drawCurrentItem(n)
  if playerInventory[n] ~= nil then
    local ID = playerInventory[n].ID
    term.setTextColor(colors.white)
    if playerInventory[n].durability ~= nil then
      for i = 1, 3 do
        paintutils.drawLine(1, (sy - 3) + i, 15,(sy - 3) + i, colors.gray)
      end
      term.setCursorPos(8 - math.floor((string.len(playerInventory[n].name) / 2)), sy - 2)
      term.write(playerInventory[n].name)
      if playerInventory[n].durability > 0 then
        paintutils.drawLine(2, sy - 1, math.ceil(13 / (Assets[ID].durability / playerInventory[n].durability) + 1), sy - 1, colors.lime)
        term.setBackgroundColor(colors.gray)
        term.setCursorPos(8 - string.len(playerInventory[n].durability),sy)
        term.write(playerInventory[n].durability.. "/" ..Assets[ID].durability)
      end
    else
      term.setBackgroundColor(colors.gray)
      term.setCursorPos(1, sy)
      term.write(" " ..playerInventory[n].name)
      term.write(" x" ..playerInventory[n].Amount.. " | ")
      term.setTextColor(playerInventory[n].Tex)
      if playerInventory[n].Tex == colors.gray then
        term.setBackgroundColor(colors.white)
      end
      term.write(playerInventory[n].Sym.. " ")
    end
  end
end

function startTimers()
  gT = os.startTimer(gameTick)
  aU = os.startTimer(aUpdate)
  gS = os.startTimer(gameSave)
end

function mainMenu()
  while true do
    term.drawScreen()
    MenuAPI.mainMenu(e, p1, p2, p3)
    e, p1, p2, p3 = os.pullEvent()
    local run, mx, my = MenuAPI.mainMenu(e, p1, p2, p3)
    if not run then
      LevelAPI.setWorldSize(mx,my)
      overworld = LevelAPI.newWorld(mx, my)
      local px, py = PlayerAPI.newPlayerPos(overworld, currentDim)
      local ox, oy = LevelAPI.getOffset()
      local pxo, pyo = px - math.floor(sx / 2), py - math.floor(sy / 2)
      worldX, worldX2 = mx, my
      PlayerAPI.setPlayerCoordinates(px, py)
      LevelAPI.setOffset(pxo, pyo)
      FileAPI.saveMap(overworld, LevelAPI.getWorldName())
      break
    end
  end
end

function updateVar()
  playerX, playerY = PlayerAPI.getPlayerCoordinates()
  playerDirection = PlayerAPI.getPlayerDirection()
  OffsetX, OffsetY = LevelAPI.getOffset()
  currentDim = PlayerAPI.getPlayerDim()
end

function updateAll()

  PlayerAPI.updatePlayer(overworld,currentDim,OffsetX,OffsetY)
  if doLighting then --Laggy/Buggy but working
    LightingAPI.drawLighting(playerX - OffsetX, playerY - OffsetY, 6)
  end
  drawCurrentItem(invNum)
  drawPlayerName(playerX, playerY, PlayerAPI.getPlayerName())
  drawPlayerStats()

  for i = 1, #loadedMods do
    if loadedMods[i].Type == "loop" then
      func = loadedMods[i].Addon
      func()
    end
  end

  term.drawScreen()
end

mainMenu()
updateVar()
updateAll()
startTimers()

while true do
  e, p1, p2, p3 = os.pullEvent()

  --[Key events]--
  if e == "key" then 
    local aU = os.startTimer(aUpdate)
    if p1 == 17 or p1 == 200 then -- Up Key
      if not overworld[currentDim][2][playerX][playerY - 1].bgT then
        if playerY - 1 < worldX2 and playerY - 1 > worldX then
          PlayerAPI.setPlayerCoordinates(playerX, playerY - 1)
          LevelAPI.setOffset(OffsetX, OffsetY - 1)
        end
      end
      if not keepDirection then
        PlayerAPI.setPlayerDirection(1)
      end

    elseif p1 == 31 or p1 == 208 then -- Down Key
      if not overworld[currentDim][2][playerX][playerY + 1].bgT then
        if playerY + 1 < worldX2 and playerY + 1 > worldX then
          PlayerAPI.setPlayerCoordinates(playerX, playerY + 1)
          LevelAPI.setOffset(OffsetX, OffsetY + 1)
        end
      end
      if not keepDirection then
        PlayerAPI.setPlayerDirection(3)
      end

    elseif p1 == 32 or p1 == 205 then -- Right Key
      if not overworld[currentDim][2][playerX + 1][playerY].bgT then
        if playerX + 1 < worldX2 and playerX + 1 > worldX then
          PlayerAPI.setPlayerCoordinates(playerX + 1, playerY)
          LevelAPI.setOffset(OffsetX + 1, OffsetY)
        end
      end
      if not keepDirection then
        PlayerAPI.setPlayerDirection(2)
      end

    elseif p1 == 30 or p1 == 203 then -- Left Key
      if not overworld[currentDim][2][playerX - 1][playerY].bgT then
        if playerX - 1 < worldX2 and playerX - 1 > worldX then
          PlayerAPI.setPlayerCoordinates(playerX - 1, playerY)
          LevelAPI.setOffset(OffsetX - 1, OffsetY)
        end
      end
      if not keepDirection then
        PlayerAPI.setPlayerDirection(4)
      end

    elseif p1 == 59 then -- F1
      --EntityAPI.newEntity(400, playerX - 2, playerY - 2)
      --EntityAPI.newEntity(401, playerX - 1, playerY - 1)
      --EntityAPI.newEntity(450, playerX + 1, playerY + 1)
      --EntityAPI.newEntity(451, playerX + 2, playerY + 2)

    elseif p1 == 60 then -- F2
      if PlayerAPI.getPlayerMode() == 0 then
        PlayerAPI.setPlayerMode(1)
      elseif PlayerAPI.getPlayerMode() == 1 then
        PlayerAPI.setPlayerMode(0)
      end

    elseif p1 == 61 then -- F3
      debug = not debug

    elseif p1 == 62 then -- F4
      if currentDim ~= -1 then
        LevelAPI.changeDimension(-1, doLighting)
      else
        LevelAPI.changeDimension(0, doLighting)
      end

    
    elseif p1 == 63 then -- F5
      term.setCursorPos(sx - 11, sy)
      term.setBackgroundColor(colors.gray)
      term.setTextColor(colors.white)
      term.write("Saving World")
      sleep(0.05)
      FileAPI.saveMap(overworld, LevelAPI.getWorldName())
      startTimers()

    elseif p1 == 42 then -- Shift
      keepDirection = not keepDirection

    elseif p1 == 18 then -- e Aka Inventory / Interact

      InteractedBlockID, InteractedTileID = PlayerAPI.getFacingBlock(overworld,currentDim,playerX,playerY,playerDirection) 
      InteractedBlockIDName, InteractedBlockID2 = LevelAPI.checkID(InteractedBlockID)
      local modInteract, modNum, modFunc = LoadAPI.checkInteractionBlocks(InteractedBlockID2)
      update = false
      menu = true

      while true do
        e, p1, p2, p3 = os.pullEvent()
        
        if CraftingAPI.checkCraftingTables(InteractedBlockID2) then
          menu, ID = CraftingAPI.openCraftingMenu(InteractedBlockID2, playerInventory, e, p1, p2, p3)
        elseif modInteract then
          menu, ID = modFunc(e, p1, p2, p3, playerX, playerY)
        else
          menu, ID, invNum = InventoryAPI.openInventory(playerInventory, e, p1, p2, p3)
          if invNum then
            if playerInventory[invNum].ID ~= nil then
              selectedItem = playerInventory[invNum].ID
            else
              selectedItem = nil
            end
          end
        end

        if menu == false then
          startTimers()
          break
        end
      end

    elseif p1 == 57 then -- Spacebar, use items
      local switch = PlayerAPI.useItem(overworld,currentDim,playerX,playerY,playerDirection,OffsetX,OffsetY,selectedItem,playerInventory)
      if switch then
        selectedItem = nil
      end
      sleep(0.05)
      startTimers()
    end

    updateVar()
    updateAll()

  --[Mouse Events]--
  elseif e == "mouse_scroll" then
  	local gm = PlayerAPI.getPlayerMode()
  	if gm == 1 then
    	selectedTile = selectedTile - p1
    end

  elseif e == "mouse_click" or e == "mouse_drag" then
  	local gm = PlayerAPI.getPlayerMode()
  	if gm == 1 then
	    if p1 == 1 then
	      if Assets[selectedTile] then
	        if Assets[selectedTile].type == "tile" then
	          overworld[currentDim][1][p2 + OffsetX][p3 + OffsetY] = Assets[selectedTile]
	        elseif Assets[selectedTile].type == "rock" or Assets[selectedTile].type == "wood" or Assets[selectedTile].type == "any" then
	          overworld[currentDim][2][p2 + OffsetX][p3 + OffsetY] = Assets[selectedTile]
	        end
	      end
	    elseif p1 == 2 then
	      if overworld[currentDim][2][p2 + OffsetX][p3 + OffsetY] then
	        overworld[currentDim][2][p2 + OffsetX][p3 + OffsetY] = {}
	      end
	    end
    	updateAll()
	end
  
  --[Timer events to update the world regularly]--
  elseif e == "timer" then
    if p1 == gT then
      if gameTime >= 24 then
        gameTime = 0
      else
        gameTime = gameTime + 0.001
      end
      gT = os.startTimer(gameTick)
    elseif p1 == aU then
      updateAll()
      aU = os.startTimer(aUpdate)
    end
  end

  --[Overlays]--
  
  if debug then
    for i = 1, 3 do
      paintutils.drawLine(1,i,sx,i,colors.gray)
    end
    --local entityList = EntityAPI.getEntityList()
    --local entityNumber = #entityList
    term.setTextColor(colors.white)
    term.setCursorPos(1,1)
    print("X: " ..playerX.. ", Y: " ..playerY.. ", OX: " ..OffsetX.. ", OY: " ..OffsetY) --.. " | #Entitys: " ..entityNumber)
    if Assets[selectedTile] then
      print("Selected: " ..Assets[selectedTile].name.. ", ID: " ..selectedTile)
    else
      print("Selected: None, ID: " ..selectedTile)
    end
    print("Game Time: " ..gameTime)
    term.setCursorPos(19,3) 
    print("(" ..textutils.formatTime(gameTime, true).. ")")
    term.setCursorPos(27,3)
    local gM, gMS = PlayerAPI.getPlayerMode(), "ERROR"
    if gM == 1 then
      gMS = "Creative"
    elseif gM == 0 then
      gMS = "Survival"
    end
    print("Game Mode: " ..gMS)
  end

  for i = 1, #loadedMods do
    if loadedMods[i].Type == "overlay" then
      func = loadedMods[i].Addon
      func()
    end
  end
end